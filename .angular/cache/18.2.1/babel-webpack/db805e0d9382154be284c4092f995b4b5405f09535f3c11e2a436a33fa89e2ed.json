{"ast":null,"code":"'use strict';\n\nconst {\n  hasOwnProperty\n} = Object.prototype;\nfunction isEqualSelectors(a, b) {\n  let cursor1 = a.head;\n  let cursor2 = b.head;\n  while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {\n    cursor1 = cursor1.next;\n    cursor2 = cursor2.next;\n  }\n  return cursor1 === null && cursor2 === null;\n}\nfunction isEqualDeclarations(a, b) {\n  let cursor1 = a.head;\n  let cursor2 = b.head;\n  while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {\n    cursor1 = cursor1.next;\n    cursor2 = cursor2.next;\n  }\n  return cursor1 === null && cursor2 === null;\n}\nfunction compareDeclarations(declarations1, declarations2) {\n  const result = {\n    eq: [],\n    ne1: [],\n    ne2: [],\n    ne2overrided: []\n  };\n  const fingerprints = Object.create(null);\n  const declarations2hash = Object.create(null);\n  for (let cursor = declarations2.head; cursor; cursor = cursor.next) {\n    declarations2hash[cursor.data.id] = true;\n  }\n  for (let cursor = declarations1.head; cursor; cursor = cursor.next) {\n    const data = cursor.data;\n    if (data.fingerprint) {\n      fingerprints[data.fingerprint] = data.important;\n    }\n    if (declarations2hash[data.id]) {\n      declarations2hash[data.id] = false;\n      result.eq.push(data);\n    } else {\n      result.ne1.push(data);\n    }\n  }\n  for (let cursor = declarations2.head; cursor; cursor = cursor.next) {\n    const data = cursor.data;\n    if (declarations2hash[data.id]) {\n      // when declarations1 has an overriding declaration, this is not a difference\n      // unless no !important is used on prev and !important is used on the following\n      if (!hasOwnProperty.call(fingerprints, data.fingerprint) || !fingerprints[data.fingerprint] && data.important) {\n        result.ne2.push(data);\n      }\n      result.ne2overrided.push(data);\n    }\n  }\n  return result;\n}\nfunction addSelectors(dest, source) {\n  source.forEach(sourceData => {\n    const newStr = sourceData.id;\n    let cursor = dest.head;\n    while (cursor) {\n      const nextStr = cursor.data.id;\n      if (nextStr === newStr) {\n        return;\n      }\n      if (nextStr > newStr) {\n        break;\n      }\n      cursor = cursor.next;\n    }\n    dest.insert(dest.createItem(sourceData), cursor);\n  });\n  return dest;\n}\n\n// check if simpleselectors has no equal specificity and element selector\nfunction hasSimilarSelectors(selectors1, selectors2) {\n  let cursor1 = selectors1.head;\n  while (cursor1 !== null) {\n    let cursor2 = selectors2.head;\n    while (cursor2 !== null) {\n      if (cursor1.data.compareMarker === cursor2.data.compareMarker) {\n        return true;\n      }\n      cursor2 = cursor2.next;\n    }\n    cursor1 = cursor1.next;\n  }\n  return false;\n}\n\n// test node can't to be skipped\nfunction unsafeToSkipNode(node) {\n  switch (node.type) {\n    case 'Rule':\n      // unsafe skip ruleset with selector similarities\n      return hasSimilarSelectors(node.prelude.children, this);\n    case 'Atrule':\n      // can skip at-rules with blocks\n      if (node.block) {\n        // unsafe skip at-rule if block contains something unsafe to skip\n        return node.block.children.some(unsafeToSkipNode, this);\n      }\n      break;\n    case 'Declaration':\n      return false;\n  }\n\n  // unsafe by default\n  return true;\n}\nexports.addSelectors = addSelectors;\nexports.compareDeclarations = compareDeclarations;\nexports.hasSimilarSelectors = hasSimilarSelectors;\nexports.isEqualDeclarations = isEqualDeclarations;\nexports.isEqualSelectors = isEqualSelectors;\nexports.unsafeToSkipNode = unsafeToSkipNode;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}