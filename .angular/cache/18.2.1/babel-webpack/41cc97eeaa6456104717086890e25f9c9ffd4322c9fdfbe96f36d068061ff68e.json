{"ast":null,"code":"'use strict';\n\nconst charCodeDefinitions = require('../tokenizer/char-code-definitions.cjs');\nconst utils = require('../tokenizer/utils.cjs');\nconst REVERSE_SOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\\)\nconst QUOTATION_MARK = 0x0022; // \"\nconst APOSTROPHE = 0x0027; // '\n\nfunction decode(str) {\n  const len = str.length;\n  const firstChar = str.charCodeAt(0);\n  const start = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE ? 1 : 0;\n  const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;\n  let decoded = '';\n  for (let i = start; i <= end; i++) {\n    let code = str.charCodeAt(i);\n    if (code === REVERSE_SOLIDUS) {\n      // special case at the ending\n      if (i === end) {\n        // if the next input code point is EOF, do nothing\n        // otherwise include last quote as escaped\n        if (i !== len - 1) {\n          decoded = str.substr(i + 1);\n        }\n        break;\n      }\n      code = str.charCodeAt(++i);\n\n      // consume escaped\n      if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {\n        const escapeStart = i - 1;\n        const escapeEnd = utils.consumeEscaped(str, escapeStart);\n        i = escapeEnd - 1;\n        decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));\n      } else {\n        // \\r\\n\n        if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {\n          i++;\n        }\n      }\n    } else {\n      decoded += str[i];\n    }\n  }\n  return decoded;\n}\n\n// https://drafts.csswg.org/cssom/#serialize-a-string\n// ยง 2.1. Common Serializing Idioms\nfunction encode(str, apostrophe) {\n  const quote = apostrophe ? '\\'' : '\"';\n  const quoteCode = apostrophe ? APOSTROPHE : QUOTATION_MARK;\n  let encoded = '';\n  let wsBeforeHexIsNeeded = false;\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n\n    // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).\n    if (code === 0x0000) {\n      encoded += '\\uFFFD';\n      continue;\n    }\n\n    // If the character is in the range [\\1-\\1f] (U+0001 to U+001F) or is U+007F,\n    // the character escaped as code point.\n    // Note: Do not compare with 0x0001 since 0x0000 is precessed before\n    if (code <= 0x001f || code === 0x007F) {\n      encoded += '\\\\' + code.toString(16);\n      wsBeforeHexIsNeeded = true;\n      continue;\n    }\n\n    // If the character is '\"' (U+0022) or \"\\\" (U+005C), the escaped character.\n    if (code === quoteCode || code === REVERSE_SOLIDUS) {\n      encoded += '\\\\' + str.charAt(i);\n      wsBeforeHexIsNeeded = false;\n    } else {\n      if (wsBeforeHexIsNeeded && (charCodeDefinitions.isHexDigit(code) || charCodeDefinitions.isWhiteSpace(code))) {\n        encoded += ' ';\n      }\n\n      // Otherwise, the character itself.\n      encoded += str.charAt(i);\n      wsBeforeHexIsNeeded = false;\n    }\n  }\n  return quote + encoded + quote;\n}\nexports.decode = decode;\nexports.encode = encode;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}