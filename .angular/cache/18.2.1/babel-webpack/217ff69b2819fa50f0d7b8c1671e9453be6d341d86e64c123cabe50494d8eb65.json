{"ast":null,"code":"'use strict';\n\n//\n//                              list\n//                            ┌──────┐\n//             ┌──────────────┼─head │\n//             │              │ tail─┼──────────────┐\n//             │              └──────┘              │\n//             ▼                                    ▼\n//            item        item        item        item\n//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐\n//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │\n//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null\n//          ├──────┤    ├──────┤    ├──────┤    ├──────┤\n//          │ data │    │ data │    │ data │    │ data │\n//          └──────┘    └──────┘    └──────┘    └──────┘\n//\nlet releasedCursors = null;\nclass List {\n  static createItem(data) {\n    return {\n      prev: null,\n      next: null,\n      data\n    };\n  }\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.cursor = null;\n  }\n  createItem(data) {\n    return List.createItem(data);\n  }\n\n  // cursor helpers\n  allocateCursor(prev, next) {\n    let cursor;\n    if (releasedCursors !== null) {\n      cursor = releasedCursors;\n      releasedCursors = releasedCursors.cursor;\n      cursor.prev = prev;\n      cursor.next = next;\n      cursor.cursor = this.cursor;\n    } else {\n      cursor = {\n        prev,\n        next,\n        cursor: this.cursor\n      };\n    }\n    this.cursor = cursor;\n    return cursor;\n  }\n  releaseCursor() {\n    const {\n      cursor\n    } = this;\n    this.cursor = cursor.cursor;\n    cursor.prev = null;\n    cursor.next = null;\n    cursor.cursor = releasedCursors;\n    releasedCursors = cursor;\n  }\n  updateCursors(prevOld, prevNew, nextOld, nextNew) {\n    let {\n      cursor\n    } = this;\n    while (cursor !== null) {\n      if (cursor.prev === prevOld) {\n        cursor.prev = prevNew;\n      }\n      if (cursor.next === nextOld) {\n        cursor.next = nextNew;\n      }\n      cursor = cursor.cursor;\n    }\n  }\n  *[Symbol.iterator]() {\n    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n      yield cursor.data;\n    }\n  }\n\n  // getters\n  get size() {\n    let size = 0;\n    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n      size++;\n    }\n    return size;\n  }\n  get isEmpty() {\n    return this.head === null;\n  }\n  get first() {\n    return this.head && this.head.data;\n  }\n  get last() {\n    return this.tail && this.tail.data;\n  }\n\n  // convertors\n  fromArray(array) {\n    let cursor = null;\n    this.head = null;\n    for (let data of array) {\n      const item = List.createItem(data);\n      if (cursor !== null) {\n        cursor.next = item;\n      } else {\n        this.head = item;\n      }\n      item.prev = cursor;\n      cursor = item;\n    }\n    this.tail = cursor;\n    return this;\n  }\n  toArray() {\n    return [...this];\n  }\n  toJSON() {\n    return [...this];\n  }\n\n  // array-like methods\n  forEach(fn, thisArg = this) {\n    // push cursor\n    const cursor = this.allocateCursor(null, this.head);\n    while (cursor.next !== null) {\n      const item = cursor.next;\n      cursor.next = item.next;\n      fn.call(thisArg, item.data, item, this);\n    }\n\n    // pop cursor\n    this.releaseCursor();\n  }\n  forEachRight(fn, thisArg = this) {\n    // push cursor\n    const cursor = this.allocateCursor(this.tail, null);\n    while (cursor.prev !== null) {\n      const item = cursor.prev;\n      cursor.prev = item.prev;\n      fn.call(thisArg, item.data, item, this);\n    }\n\n    // pop cursor\n    this.releaseCursor();\n  }\n  reduce(fn, initialValue, thisArg = this) {\n    // push cursor\n    let cursor = this.allocateCursor(null, this.head);\n    let acc = initialValue;\n    let item;\n    while (cursor.next !== null) {\n      item = cursor.next;\n      cursor.next = item.next;\n      acc = fn.call(thisArg, acc, item.data, item, this);\n    }\n\n    // pop cursor\n    this.releaseCursor();\n    return acc;\n  }\n  reduceRight(fn, initialValue, thisArg = this) {\n    // push cursor\n    let cursor = this.allocateCursor(this.tail, null);\n    let acc = initialValue;\n    let item;\n    while (cursor.prev !== null) {\n      item = cursor.prev;\n      cursor.prev = item.prev;\n      acc = fn.call(thisArg, acc, item.data, item, this);\n    }\n\n    // pop cursor\n    this.releaseCursor();\n    return acc;\n  }\n  some(fn, thisArg = this) {\n    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n      if (fn.call(thisArg, cursor.data, cursor, this)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  map(fn, thisArg = this) {\n    const result = new List();\n    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n      result.appendData(fn.call(thisArg, cursor.data, cursor, this));\n    }\n    return result;\n  }\n  filter(fn, thisArg = this) {\n    const result = new List();\n    for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n      if (fn.call(thisArg, cursor.data, cursor, this)) {\n        result.appendData(cursor.data);\n      }\n    }\n    return result;\n  }\n  nextUntil(start, fn, thisArg = this) {\n    if (start === null) {\n      return;\n    }\n\n    // push cursor\n    const cursor = this.allocateCursor(null, start);\n    while (cursor.next !== null) {\n      const item = cursor.next;\n      cursor.next = item.next;\n      if (fn.call(thisArg, item.data, item, this)) {\n        break;\n      }\n    }\n\n    // pop cursor\n    this.releaseCursor();\n  }\n  prevUntil(start, fn, thisArg = this) {\n    if (start === null) {\n      return;\n    }\n\n    // push cursor\n    const cursor = this.allocateCursor(start, null);\n    while (cursor.prev !== null) {\n      const item = cursor.prev;\n      cursor.prev = item.prev;\n      if (fn.call(thisArg, item.data, item, this)) {\n        break;\n      }\n    }\n\n    // pop cursor\n    this.releaseCursor();\n  }\n\n  // mutation\n  clear() {\n    this.head = null;\n    this.tail = null;\n  }\n  copy() {\n    const result = new List();\n    for (let data of this) {\n      result.appendData(data);\n    }\n    return result;\n  }\n  prepend(item) {\n    //      head\n    //    ^\n    // item\n    this.updateCursors(null, item, this.head, item);\n\n    // insert to the beginning of the list\n    if (this.head !== null) {\n      // new item <- first item\n      this.head.prev = item;\n      // new item -> first item\n      item.next = this.head;\n    } else {\n      // if list has no head, then it also has no tail\n      // in this case tail points to the new item\n      this.tail = item;\n    }\n\n    // head always points to new item\n    this.head = item;\n    return this;\n  }\n  prependData(data) {\n    return this.prepend(List.createItem(data));\n  }\n  append(item) {\n    return this.insert(item);\n  }\n  appendData(data) {\n    return this.insert(List.createItem(data));\n  }\n  insert(item, before = null) {\n    if (before !== null) {\n      // prev   before\n      //      ^\n      //     item\n      this.updateCursors(before.prev, item, before, item);\n      if (before.prev === null) {\n        // insert to the beginning of list\n        if (this.head !== before) {\n          throw new Error('before doesn\\'t belong to list');\n        }\n        // since head points to before therefore list doesn't empty\n        // no need to check tail\n        this.head = item;\n        before.prev = item;\n        item.next = before;\n        this.updateCursors(null, item);\n      } else {\n        // insert between two items\n        before.prev.next = item;\n        item.prev = before.prev;\n        before.prev = item;\n        item.next = before;\n      }\n    } else {\n      // tail\n      //      ^\n      //      item\n      this.updateCursors(this.tail, item, null, item);\n\n      // insert to the ending of the list\n      if (this.tail !== null) {\n        // last item -> new item\n        this.tail.next = item;\n        // last item <- new item\n        item.prev = this.tail;\n      } else {\n        // if list has no tail, then it also has no head\n        // in this case head points to new item\n        this.head = item;\n      }\n\n      // tail always points to new item\n      this.tail = item;\n    }\n    return this;\n  }\n  insertData(data, before) {\n    return this.insert(List.createItem(data), before);\n  }\n  remove(item) {\n    //      item\n    //       ^\n    // prev     next\n    this.updateCursors(item, item.prev, item, item.next);\n    if (item.prev !== null) {\n      item.prev.next = item.next;\n    } else {\n      if (this.head !== item) {\n        throw new Error('item doesn\\'t belong to list');\n      }\n      this.head = item.next;\n    }\n    if (item.next !== null) {\n      item.next.prev = item.prev;\n    } else {\n      if (this.tail !== item) {\n        throw new Error('item doesn\\'t belong to list');\n      }\n      this.tail = item.prev;\n    }\n    item.prev = null;\n    item.next = null;\n    return item;\n  }\n  push(data) {\n    this.insert(List.createItem(data));\n  }\n  pop() {\n    return this.tail !== null ? this.remove(this.tail) : null;\n  }\n  unshift(data) {\n    this.prepend(List.createItem(data));\n  }\n  shift() {\n    return this.head !== null ? this.remove(this.head) : null;\n  }\n  prependList(list) {\n    return this.insertList(list, this.head);\n  }\n  appendList(list) {\n    return this.insertList(list);\n  }\n  insertList(list, before) {\n    // ignore empty lists\n    if (list.head === null) {\n      return this;\n    }\n    if (before !== undefined && before !== null) {\n      this.updateCursors(before.prev, list.tail, before, list.head);\n\n      // insert in the middle of dist list\n      if (before.prev !== null) {\n        // before.prev <-> list.head\n        before.prev.next = list.head;\n        list.head.prev = before.prev;\n      } else {\n        this.head = list.head;\n      }\n      before.prev = list.tail;\n      list.tail.next = before;\n    } else {\n      this.updateCursors(this.tail, list.tail, null, list.head);\n\n      // insert to end of the list\n      if (this.tail !== null) {\n        // if destination list has a tail, then it also has a head,\n        // but head doesn't change\n        // dest tail -> source head\n        this.tail.next = list.head;\n        // dest tail <- source head\n        list.head.prev = this.tail;\n      } else {\n        // if list has no a tail, then it also has no a head\n        // in this case points head to new item\n        this.head = list.head;\n      }\n\n      // tail always start point to new item\n      this.tail = list.tail;\n    }\n    list.head = null;\n    list.tail = null;\n    return this;\n  }\n  replace(oldItem, newItemOrList) {\n    if ('head' in newItemOrList) {\n      this.insertList(newItemOrList, oldItem);\n    } else {\n      this.insert(newItemOrList, oldItem);\n    }\n    this.remove(oldItem);\n  }\n}\nexports.List = List;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}