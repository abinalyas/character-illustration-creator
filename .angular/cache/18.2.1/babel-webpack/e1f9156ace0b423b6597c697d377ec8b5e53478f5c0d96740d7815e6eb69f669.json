{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastParent} XastParent\n */\nconst csstree = require('css-tree');\nconst {\n  syntax: {\n    specificity\n  }\n} = require('csso');\nconst {\n  visitSkip,\n  querySelectorAll,\n  detachNodeFromParent\n} = require('../lib/xast.js');\nconst {\n  compareSpecificity,\n  includesAttrSelector\n} = require('../lib/style');\nconst {\n  attrsGroups,\n  pseudoClasses\n} = require('./_collections');\nexports.name = 'inlineStyles';\nexports.description = 'inline styles (additional options)';\n\n/**\n * Some pseudo-classes can only be calculated by clients, like :visited,\n * :future, or :hover, but there are other pseudo-classes that we can evaluate\n * during optimization.\n *\n * The list of pseudo-classes that we can evaluate during optimization, and so\n * shouldn't be toggled conditionally through the `usePseudos` parameter.\n *\n * @see https://developer.mozilla.org/docs/Web/CSS/Pseudo-classes\n */\nconst preservedPseudos = [...pseudoClasses.functional, ...pseudoClasses.treeStructural];\n\n/**\n * Merges styles from style nodes into inline styles.\n *\n * @type {import('./plugins-types').Plugin<'inlineStyles'>}\n * @author strarsis <strarsis@gmail.com>\n */\nexports.fn = (root, params) => {\n  const {\n    onlyMatchedOnce = true,\n    removeMatchedSelectors = true,\n    useMqs = ['', 'screen'],\n    usePseudos = ['']\n  } = params;\n\n  /**\n   * @type {{ node: XastElement, parentNode: XastParent, cssAst: csstree.StyleSheet }[]}\n   */\n  const styles = [];\n  /**\n   * @type {{\n   *   node: csstree.Selector,\n   *   item: csstree.ListItem<csstree.CssNode>,\n   *   rule: csstree.Rule,\n   *   matchedElements?: XastElement[]\n   * }[]}\n   */\n  let selectors = [];\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        if (node.name === 'foreignObject') {\n          return visitSkip;\n        }\n        if (node.name !== 'style' || node.children.length === 0) {\n          return;\n        }\n        if (node.attributes.type != null && node.attributes.type !== '' && node.attributes.type !== 'text/css') {\n          return;\n        }\n        const cssText = node.children.filter(child => child.type === 'text' || child.type === 'cdata')\n        // @ts-ignore\n        .map(child => child.value).join('');\n\n        /** @type {?csstree.CssNode} */\n        let cssAst = null;\n        try {\n          cssAst = csstree.parse(cssText, {\n            parseValue: false,\n            parseCustomProperty: false\n          });\n        } catch {\n          return;\n        }\n        if (cssAst.type === 'StyleSheet') {\n          styles.push({\n            node,\n            parentNode,\n            cssAst\n          });\n        }\n\n        // collect selectors\n        csstree.walk(cssAst, {\n          visit: 'Rule',\n          enter(node) {\n            const atrule = this.atrule;\n\n            // skip media queries not included into useMqs param\n            let mediaQuery = '';\n            if (atrule != null) {\n              mediaQuery = atrule.name;\n              if (atrule.prelude != null) {\n                mediaQuery += ` ${csstree.generate(atrule.prelude)}`;\n              }\n            }\n            if (!useMqs.includes(mediaQuery)) {\n              return;\n            }\n            if (node.prelude.type === 'SelectorList') {\n              node.prelude.children.forEach((childNode, item) => {\n                if (childNode.type === 'Selector') {\n                  /**\n                   * @type {{\n                   *   item: csstree.ListItem<csstree.CssNode>,\n                   *   list: csstree.List<csstree.CssNode>\n                   * }[]}\n                   */\n                  const pseudos = [];\n                  childNode.children.forEach((grandchildNode, grandchildItem, grandchildList) => {\n                    const isPseudo = grandchildNode.type === 'PseudoClassSelector' || grandchildNode.type === 'PseudoElementSelector';\n                    if (isPseudo && !preservedPseudos.includes(grandchildNode.name)) {\n                      pseudos.push({\n                        item: grandchildItem,\n                        list: grandchildList\n                      });\n                    }\n                  });\n                  const pseudoSelectors = csstree.generate({\n                    type: 'Selector',\n                    children: new csstree.List().fromArray(pseudos.map(pseudo => pseudo.item.data))\n                  });\n                  if (usePseudos.includes(pseudoSelectors)) {\n                    for (const pseudo of pseudos) {\n                      pseudo.list.remove(pseudo.item);\n                    }\n                  }\n                  selectors.push({\n                    node: childNode,\n                    rule: node,\n                    item: item\n                  });\n                }\n              });\n            }\n          }\n        });\n      }\n    },\n    root: {\n      exit: () => {\n        if (styles.length === 0) {\n          return;\n        }\n        const sortedSelectors = selectors.slice().sort((a, b) => {\n          const aSpecificity = specificity(a.item.data);\n          const bSpecificity = specificity(b.item.data);\n          return compareSpecificity(aSpecificity, bSpecificity);\n        }).reverse();\n        for (const selector of sortedSelectors) {\n          // match selectors\n          const selectorText = csstree.generate(selector.item.data);\n          /** @type {XastElement[]} */\n          const matchedElements = [];\n          try {\n            for (const node of querySelectorAll(root, selectorText)) {\n              if (node.type === 'element') {\n                matchedElements.push(node);\n              }\n            }\n          } catch (selectError) {\n            continue;\n          }\n          // nothing selected\n          if (matchedElements.length === 0) {\n            continue;\n          }\n\n          // apply styles to matched elements\n          // skip selectors that match more than once if option onlyMatchedOnce is enabled\n          if (onlyMatchedOnce && matchedElements.length > 1) {\n            continue;\n          }\n\n          // apply <style/> to matched elements\n          for (const selectedEl of matchedElements) {\n            const styleDeclarationList = csstree.parse(selectedEl.attributes.style ?? '', {\n              context: 'declarationList',\n              parseValue: false\n            });\n            if (styleDeclarationList.type !== 'DeclarationList') {\n              continue;\n            }\n            const styleDeclarationItems = new Map();\n\n            /** @type {csstree.ListItem<csstree.CssNode>} */\n            let firstListItem;\n            csstree.walk(styleDeclarationList, {\n              visit: 'Declaration',\n              enter(node, item) {\n                if (firstListItem == null) {\n                  firstListItem = item;\n                }\n                styleDeclarationItems.set(node.property.toLowerCase(), item);\n              }\n            });\n            // merge declarations\n            csstree.walk(selector.rule, {\n              visit: 'Declaration',\n              enter(ruleDeclaration) {\n                // existing inline styles have higher priority\n                // no inline styles, external styles,                                    external styles used\n                // inline styles,    external styles same   priority as inline styles,   inline   styles used\n                // inline styles,    external styles higher priority than inline styles, external styles used\n                const property = ruleDeclaration.property;\n                if (attrsGroups.presentation.has(property) && !selectors.some(selector => includesAttrSelector(selector.item, property))) {\n                  delete selectedEl.attributes[property];\n                }\n                const matchedItem = styleDeclarationItems.get(property);\n                const ruleDeclarationItem = styleDeclarationList.children.createItem(ruleDeclaration);\n                if (matchedItem == null) {\n                  styleDeclarationList.children.insert(ruleDeclarationItem, firstListItem);\n                } else if (matchedItem.data.important !== true && ruleDeclaration.important === true) {\n                  styleDeclarationList.children.replace(matchedItem, ruleDeclarationItem);\n                  styleDeclarationItems.set(property, ruleDeclarationItem);\n                }\n              }\n            });\n            const newStyles = csstree.generate(styleDeclarationList);\n            if (newStyles.length !== 0) {\n              selectedEl.attributes.style = newStyles;\n            }\n          }\n          if (removeMatchedSelectors && matchedElements.length !== 0 && selector.rule.prelude.type === 'SelectorList') {\n            // clean up matching simple selectors if option removeMatchedSelectors is enabled\n            selector.rule.prelude.children.remove(selector.item);\n          }\n          selector.matchedElements = matchedElements;\n        }\n\n        // no further processing required\n        if (!removeMatchedSelectors) {\n          return;\n        }\n\n        // clean up matched class + ID attribute values\n        for (const selector of sortedSelectors) {\n          if (selector.matchedElements == null) {\n            continue;\n          }\n          if (onlyMatchedOnce && selector.matchedElements.length > 1) {\n            // skip selectors that match more than once if option onlyMatchedOnce is enabled\n            continue;\n          }\n          for (const selectedEl of selector.matchedElements) {\n            // class\n            const classList = new Set(selectedEl.attributes.class == null ? null : selectedEl.attributes.class.split(' '));\n            for (const child of selector.node.children) {\n              if (child.type === 'ClassSelector' && !selectors.some(selector => includesAttrSelector(selector.item, 'class', child.name, true))) {\n                classList.delete(child.name);\n              }\n            }\n            if (classList.size === 0) {\n              delete selectedEl.attributes.class;\n            } else {\n              selectedEl.attributes.class = Array.from(classList).join(' ');\n            }\n\n            // ID\n            const firstSubSelector = selector.node.children.first;\n            if (firstSubSelector?.type === 'IdSelector' && selectedEl.attributes.id === firstSubSelector.name && !selectors.some(selector => includesAttrSelector(selector.item, 'id', firstSubSelector.name, true))) {\n              delete selectedEl.attributes.id;\n            }\n          }\n        }\n        for (const style of styles) {\n          csstree.walk(style.cssAst, {\n            visit: 'Rule',\n            enter: function (node, item, list) {\n              // clean up <style/> rulesets without any css selectors left\n              if (node.type === 'Rule' && node.prelude.type === 'SelectorList' && node.prelude.children.isEmpty) {\n                list.remove(item);\n              }\n            }\n          });\n\n          // csstree v2 changed this type\n          if (style.cssAst.children.isEmpty) {\n            // remove empty style element\n            detachNodeFromParent(style.node, style.parentNode);\n          } else {\n            // update style element if any styles left\n            const firstChild = style.node.children[0];\n            if (firstChild.type === 'text' || firstChild.type === 'cdata') {\n              firstChild.value = csstree.generate(style.cssAst);\n            }\n          }\n        }\n      }\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}