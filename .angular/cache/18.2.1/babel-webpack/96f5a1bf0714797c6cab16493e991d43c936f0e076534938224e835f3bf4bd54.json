{"ast":null,"code":"'use strict';\n\nconst createCustomError = require('../utils/create-custom-error.cjs');\nconst generate = require('../definition-syntax/generate.cjs');\nconst defaultLoc = {\n  offset: 0,\n  line: 1,\n  column: 1\n};\nfunction locateMismatch(matchResult, node) {\n  const tokens = matchResult.tokens;\n  const longestMatch = matchResult.longestMatch;\n  const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;\n  const badNode = mismatchNode !== node ? mismatchNode : null;\n  let mismatchOffset = 0;\n  let mismatchLength = 0;\n  let entries = 0;\n  let css = '';\n  let start;\n  let end;\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i].value;\n    if (i === longestMatch) {\n      mismatchLength = token.length;\n      mismatchOffset = css.length;\n    }\n    if (badNode !== null && tokens[i].node === badNode) {\n      if (i <= longestMatch) {\n        entries++;\n      } else {\n        entries = 0;\n      }\n    }\n    css += token;\n  }\n  if (longestMatch === tokens.length || entries > 1) {\n    // last\n    start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);\n    end = buildLoc(start);\n  } else {\n    start = fromLoc(badNode, 'start') || buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));\n    end = fromLoc(badNode, 'end') || buildLoc(start, css.substr(mismatchOffset, mismatchLength));\n  }\n  return {\n    css,\n    mismatchOffset,\n    mismatchLength,\n    start,\n    end\n  };\n}\nfunction fromLoc(node, point) {\n  const value = node && node.loc && node.loc[point];\n  if (value) {\n    return 'line' in value ? buildLoc(value) : value;\n  }\n  return null;\n}\nfunction buildLoc({\n  offset,\n  line,\n  column\n}, extra) {\n  const loc = {\n    offset,\n    line,\n    column\n  };\n  if (extra) {\n    const lines = extra.split(/\\n|\\r\\n?|\\f/);\n    loc.offset += extra.length;\n    loc.line += lines.length - 1;\n    loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;\n  }\n  return loc;\n}\nconst SyntaxReferenceError = function (type, referenceName) {\n  const error = createCustomError.createCustomError('SyntaxReferenceError', type + (referenceName ? ' `' + referenceName + '`' : ''));\n  error.reference = referenceName;\n  return error;\n};\nconst SyntaxMatchError = function (message, syntax, node, matchResult) {\n  const error = createCustomError.createCustomError('SyntaxMatchError', message);\n  const {\n    css,\n    mismatchOffset,\n    mismatchLength,\n    start,\n    end\n  } = locateMismatch(matchResult, node);\n  error.rawMessage = message;\n  error.syntax = syntax ? generate.generate(syntax) : '<generic>';\n  error.css = css;\n  error.mismatchOffset = mismatchOffset;\n  error.mismatchLength = mismatchLength;\n  error.message = message + '\\n' + '  syntax: ' + error.syntax + '\\n' + '   value: ' + (css || '<empty string>') + '\\n' + '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';\n  Object.assign(error, start);\n  error.loc = {\n    source: node && node.loc && node.loc.source || '<unknown>',\n    start,\n    end\n  };\n  return error;\n};\nexports.SyntaxMatchError = SyntaxMatchError;\nexports.SyntaxReferenceError = SyntaxReferenceError;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}