{"ast":null,"code":"'use strict';\n\nconst charCodeDefinitions = require('../tokenizer/char-code-definitions.cjs');\nconst utils = require('../tokenizer/utils.cjs');\nconst SPACE = 0x0020; // U+0020 SPACE\nconst REVERSE_SOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\\)\nconst QUOTATION_MARK = 0x0022; // \"\nconst APOSTROPHE = 0x0027; // '\nconst LEFTPARENTHESIS = 0x0028; // U+0028 LEFT PARENTHESIS (()\nconst RIGHTPARENTHESIS = 0x0029; // U+0029 RIGHT PARENTHESIS ())\n\nfunction decode(str) {\n  const len = str.length;\n  let start = 4; // length of \"url(\"\n  let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;\n  let decoded = '';\n  while (start < end && charCodeDefinitions.isWhiteSpace(str.charCodeAt(start))) {\n    start++;\n  }\n  while (start < end && charCodeDefinitions.isWhiteSpace(str.charCodeAt(end))) {\n    end--;\n  }\n  for (let i = start; i <= end; i++) {\n    let code = str.charCodeAt(i);\n    if (code === REVERSE_SOLIDUS) {\n      // special case at the ending\n      if (i === end) {\n        // if the next input code point is EOF, do nothing\n        // otherwise include last left parenthesis as escaped\n        if (i !== len - 1) {\n          decoded = str.substr(i + 1);\n        }\n        break;\n      }\n      code = str.charCodeAt(++i);\n\n      // consume escaped\n      if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {\n        const escapeStart = i - 1;\n        const escapeEnd = utils.consumeEscaped(str, escapeStart);\n        i = escapeEnd - 1;\n        decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));\n      } else {\n        // \\r\\n\n        if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {\n          i++;\n        }\n      }\n    } else {\n      decoded += str[i];\n    }\n  }\n  return decoded;\n}\nfunction encode(str) {\n  let encoded = '';\n  let wsBeforeHexIsNeeded = false;\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n\n    // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).\n    if (code === 0x0000) {\n      encoded += '\\uFFFD';\n      continue;\n    }\n\n    // If the character is in the range [\\1-\\1f] (U+0001 to U+001F) or is U+007F,\n    // the character escaped as code point.\n    // Note: Do not compare with 0x0001 since 0x0000 is precessed before\n    if (code <= 0x001f || code === 0x007F) {\n      encoded += '\\\\' + code.toString(16);\n      wsBeforeHexIsNeeded = true;\n      continue;\n    }\n    if (code === SPACE || code === REVERSE_SOLIDUS || code === QUOTATION_MARK || code === APOSTROPHE || code === LEFTPARENTHESIS || code === RIGHTPARENTHESIS) {\n      encoded += '\\\\' + str.charAt(i);\n      wsBeforeHexIsNeeded = false;\n    } else {\n      if (wsBeforeHexIsNeeded && charCodeDefinitions.isHexDigit(code)) {\n        encoded += ' ';\n      }\n      encoded += str.charAt(i);\n      wsBeforeHexIsNeeded = false;\n    }\n  }\n  return 'url(' + encoded + ')';\n}\nexports.decode = decode;\nexports.encode = encode;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}