{"ast":null,"code":"'use strict';\n\nconst cssTree = require('css-tree');\nconst usage = require('./usage.cjs');\nconst index = require('./clean/index.cjs');\nconst index$1 = require('./replace/index.cjs');\nconst index$2 = require('./restructure/index.cjs');\nfunction readChunk(input, specialComments) {\n  const children = new cssTree.List();\n  let nonSpaceTokenInBuffer = false;\n  let protectedComment;\n  input.nextUntil(input.head, (node, item, list) => {\n    if (node.type === 'Comment') {\n      if (!specialComments || node.value.charAt(0) !== '!') {\n        list.remove(item);\n        return;\n      }\n      if (nonSpaceTokenInBuffer || protectedComment) {\n        return true;\n      }\n      list.remove(item);\n      protectedComment = node;\n      return;\n    }\n    if (node.type !== 'WhiteSpace') {\n      nonSpaceTokenInBuffer = true;\n    }\n    children.insert(list.remove(item));\n  });\n  return {\n    comment: protectedComment,\n    stylesheet: {\n      type: 'StyleSheet',\n      loc: null,\n      children\n    }\n  };\n}\nfunction compressChunk(ast, firstAtrulesAllowed, num, options) {\n  options.logger(`Compress block #${num}`, null, true);\n  let seed = 1;\n  if (ast.type === 'StyleSheet') {\n    ast.firstAtrulesAllowed = firstAtrulesAllowed;\n    ast.id = seed++;\n  }\n  cssTree.walk(ast, {\n    visit: 'Atrule',\n    enter(node) {\n      if (node.block !== null) {\n        node.block.id = seed++;\n      }\n    }\n  });\n  options.logger('init', ast);\n\n  // remove redundant\n  index(ast, options);\n  options.logger('clean', ast);\n\n  // replace nodes for shortened forms\n  index$1(ast);\n  options.logger('replace', ast);\n\n  // structure optimisations\n  if (options.restructuring) {\n    index$2(ast, options);\n  }\n  return ast;\n}\nfunction getCommentsOption(options) {\n  let comments = 'comments' in options ? options.comments : 'exclamation';\n  if (typeof comments === 'boolean') {\n    comments = comments ? 'exclamation' : false;\n  } else if (comments !== 'exclamation' && comments !== 'first-exclamation') {\n    comments = false;\n  }\n  return comments;\n}\nfunction getRestructureOption(options) {\n  if ('restructure' in options) {\n    return options.restructure;\n  }\n  return 'restructuring' in options ? options.restructuring : true;\n}\nfunction wrapBlock(block) {\n  return new cssTree.List().appendData({\n    type: 'Rule',\n    loc: null,\n    prelude: {\n      type: 'SelectorList',\n      loc: null,\n      children: new cssTree.List().appendData({\n        type: 'Selector',\n        loc: null,\n        children: new cssTree.List().appendData({\n          type: 'TypeSelector',\n          loc: null,\n          name: 'x'\n        })\n      })\n    },\n    block\n  });\n}\nfunction compress(ast, options) {\n  ast = ast || {\n    type: 'StyleSheet',\n    loc: null,\n    children: new cssTree.List()\n  };\n  options = options || {};\n  const compressOptions = {\n    logger: typeof options.logger === 'function' ? options.logger : function () {},\n    restructuring: getRestructureOption(options),\n    forceMediaMerge: Boolean(options.forceMediaMerge),\n    usage: options.usage ? usage.buildIndex(options.usage) : false\n  };\n  const output = new cssTree.List();\n  let specialComments = getCommentsOption(options);\n  let firstAtrulesAllowed = true;\n  let input;\n  let chunk;\n  let chunkNum = 1;\n  let chunkChildren;\n  if (options.clone) {\n    ast = cssTree.clone(ast);\n  }\n  if (ast.type === 'StyleSheet') {\n    input = ast.children;\n    ast.children = output;\n  } else {\n    input = wrapBlock(ast);\n  }\n  do {\n    chunk = readChunk(input, Boolean(specialComments));\n    compressChunk(chunk.stylesheet, firstAtrulesAllowed, chunkNum++, compressOptions);\n    chunkChildren = chunk.stylesheet.children;\n    if (chunk.comment) {\n      // add \\n before comment if there is another content in output\n      if (!output.isEmpty) {\n        output.insert(cssTree.List.createItem({\n          type: 'Raw',\n          value: '\\n'\n        }));\n      }\n      output.insert(cssTree.List.createItem(chunk.comment));\n\n      // add \\n after comment if chunk is not empty\n      if (!chunkChildren.isEmpty) {\n        output.insert(cssTree.List.createItem({\n          type: 'Raw',\n          value: '\\n'\n        }));\n      }\n    }\n    if (firstAtrulesAllowed && !chunkChildren.isEmpty) {\n      const lastRule = chunkChildren.last;\n      if (lastRule.type !== 'Atrule' || lastRule.name !== 'import' && lastRule.name !== 'charset') {\n        firstAtrulesAllowed = false;\n      }\n    }\n    if (specialComments !== 'exclamation') {\n      specialComments = false;\n    }\n    output.appendList(chunkChildren);\n  } while (!input.isEmpty);\n  return {\n    ast\n  };\n}\nmodule.exports = compress;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}