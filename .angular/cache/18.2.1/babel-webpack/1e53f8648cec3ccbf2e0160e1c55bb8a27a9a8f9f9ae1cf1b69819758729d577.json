{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../../lib/types').XastElement} XastElement\n * @typedef {import('../types').PathDataCommand} PathDataCommand\n * @typedef {import('../types').DataUri} DataUri\n */\nconst {\n  attrsGroups,\n  referencesProps\n} = require('../../plugins/_collections');\nconst regReferencesUrl = /\\burl\\(([\"'])?#(.+?)\\1\\)/g;\nconst regReferencesHref = /^#(.+?)$/;\nconst regReferencesBegin = /(\\w+)\\.[a-zA-Z]/;\n\n/**\n * Encode plain SVG data string into Data URI string.\n *\n * @type {(str: string, type?: DataUri) => string}\n */\nexports.encodeSVGDatauri = (str, type) => {\n  var prefix = 'data:image/svg+xml';\n  if (!type || type === 'base64') {\n    // base64\n    prefix += ';base64,';\n    str = prefix + Buffer.from(str).toString('base64');\n  } else if (type === 'enc') {\n    // URI encoded\n    str = prefix + ',' + encodeURIComponent(str);\n  } else if (type === 'unenc') {\n    // unencoded\n    str = prefix + ',' + str;\n  }\n  return str;\n};\n\n/**\n * Decode SVG Data URI string into plain SVG string.\n *\n * @type {(str: string) => string}\n */\nexports.decodeSVGDatauri = str => {\n  var regexp = /data:image\\/svg\\+xml(;charset=[^;,]*)?(;base64)?,(.*)/;\n  var match = regexp.exec(str);\n\n  // plain string\n  if (!match) return str;\n  var data = match[3];\n  if (match[2]) {\n    // base64\n    str = Buffer.from(data, 'base64').toString('utf8');\n  } else if (data.charAt(0) === '%') {\n    // URI encoded\n    str = decodeURIComponent(data);\n  } else if (data.charAt(0) === '<') {\n    // unencoded\n    str = data;\n  }\n  return str;\n};\n\n/**\n * @typedef {{\n *   noSpaceAfterFlags?: boolean,\n *   leadingZero?: boolean,\n *   negativeExtraSpace?: boolean\n * }} CleanupOutDataParams\n */\n\n/**\n * Convert a row of numbers to an optimized string view.\n *\n * @example\n * [0, -1, .5, .5] → \"0-1 .5.5\"\n *\n * @type {(data: number[], params: CleanupOutDataParams, command?: PathDataCommand) => string}\n */\nexports.cleanupOutData = (data, params, command) => {\n  let str = '';\n  let delimiter;\n  /**\n   * @type {number}\n   */\n  let prev;\n  data.forEach((item, i) => {\n    // space delimiter by default\n    delimiter = ' ';\n\n    // no extra space in front of first number\n    if (i == 0) delimiter = '';\n\n    // no extra space after 'arcto' command flags(large-arc and sweep flags)\n    // a20 60 45 0 1 30 20 → a20 60 45 0130 20\n    if (params.noSpaceAfterFlags && (command == 'A' || command == 'a')) {\n      var pos = i % 7;\n      if (pos == 4 || pos == 5) delimiter = '';\n    }\n\n    // remove floating-point numbers leading zeros\n    // 0.5 → .5\n    // -0.5 → -.5\n    const itemStr = params.leadingZero ? removeLeadingZero(item) : item.toString();\n\n    // no extra space in front of negative number or\n    // in front of a floating number if a previous number is floating too\n    if (params.negativeExtraSpace && delimiter != '' && (item < 0 || itemStr.charAt(0) === '.' && prev % 1 !== 0)) {\n      delimiter = '';\n    }\n    // save prev item value\n    prev = item;\n    str += delimiter + itemStr;\n  });\n  return str;\n};\n\n/**\n * Remove floating-point numbers leading zero.\n *\n * @param {number} value\n * @returns {string}\n * @example\n * 0.5 → .5\n * -0.5 → -.5\n */\nconst removeLeadingZero = value => {\n  const strValue = value.toString();\n  if (0 < value && value < 1 && strValue.startsWith('0')) {\n    return strValue.slice(1);\n  }\n  if (-1 < value && value < 0 && strValue[1] === '0') {\n    return strValue[0] + strValue.slice(2);\n  }\n  return strValue;\n};\nexports.removeLeadingZero = removeLeadingZero;\n\n/**\n * If the current node contains any scripts. This does not check parents or\n * children of the node, only the properties and attributes of the node itself.\n *\n * @param {XastElement} node Current node to check against.\n * @returns {boolean} If the current node contains scripts.\n */\nconst hasScripts = node => {\n  if (node.name === 'script' && node.children.length !== 0) {\n    return true;\n  }\n  if (node.name === 'a') {\n    const hasJsLinks = Object.entries(node.attributes).some(([attrKey, attrValue]) => (attrKey === 'href' || attrKey.endsWith(':href')) && attrValue != null && attrValue.trimStart().startsWith('javascript:'));\n    if (hasJsLinks) {\n      return true;\n    }\n  }\n  const eventAttrs = [...attrsGroups.animationEvent, ...attrsGroups.documentEvent, ...attrsGroups.documentElementEvent, ...attrsGroups.globalEvent, ...attrsGroups.graphicalEvent];\n  return eventAttrs.some(attr => node.attributes[attr] != null);\n};\nexports.hasScripts = hasScripts;\n\n/**\n * For example, a string that contains one or more of following would match and\n * return true:\n *\n * * `url(#gradient001)`\n * * `url('#gradient001')`\n *\n * @param {string} body\n * @returns {boolean} If the given string includes a URL reference.\n */\nconst includesUrlReference = body => {\n  return new RegExp(regReferencesUrl).test(body);\n};\nexports.includesUrlReference = includesUrlReference;\n\n/**\n * @param {string} attribute\n * @param {string} value\n * @returns {string[]}\n */\nconst findReferences = (attribute, value) => {\n  const results = [];\n  if (referencesProps.has(attribute)) {\n    const matches = value.matchAll(regReferencesUrl);\n    for (const match of matches) {\n      results.push(match[2]);\n    }\n  }\n  if (attribute === 'href' || attribute.endsWith(':href')) {\n    const match = regReferencesHref.exec(value);\n    if (match != null) {\n      results.push(match[1]);\n    }\n  }\n  if (attribute === 'begin') {\n    const match = regReferencesBegin.exec(value);\n    if (match != null) {\n      results.push(match[1]);\n    }\n  }\n  return results.map(body => decodeURI(body));\n};\nexports.findReferences = findReferences;\n\n/**\n * Does the same as {@link Number.toFixed} but without casting\n * the return value to a string.\n *\n * @param {number} num\n * @param {number} precision\n * @returns {number}\n */\nconst toFixed = (num, precision) => {\n  const pow = 10 ** precision;\n  return Math.round(num * pow) / pow;\n};\nexports.toFixed = toFixed;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}