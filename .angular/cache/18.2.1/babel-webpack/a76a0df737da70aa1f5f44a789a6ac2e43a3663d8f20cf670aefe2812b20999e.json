{"ast":null,"code":"'use strict';\n\nfunction appendOrSet(a, b) {\n  if (typeof b === 'string' && /^\\s*\\|/.test(b)) {\n    return typeof a === 'string' ? a + b : b.replace(/^\\s*\\|\\s*/, '');\n  }\n  return b || null;\n}\nfunction sliceProps(obj, props) {\n  const result = Object.create(null);\n  for (const [key, value] of Object.entries(obj)) {\n    if (value) {\n      result[key] = {};\n      for (const prop of Object.keys(value)) {\n        if (props.includes(prop)) {\n          result[key][prop] = value[prop];\n        }\n      }\n    }\n  }\n  return result;\n}\nfunction mix(dest, src) {\n  const result = {\n    ...dest\n  };\n  for (const [prop, value] of Object.entries(src)) {\n    switch (prop) {\n      case 'generic':\n        result[prop] = Boolean(value);\n        break;\n      case 'units':\n        result[prop] = {\n          ...dest[prop]\n        };\n        for (const [name, patch] of Object.entries(value)) {\n          result[prop][name] = Array.isArray(patch) ? patch : [];\n        }\n        break;\n      case 'atrules':\n        result[prop] = {\n          ...dest[prop]\n        };\n        for (const [name, atrule] of Object.entries(value)) {\n          const exists = result[prop][name] || {};\n          const current = result[prop][name] = {\n            prelude: exists.prelude || null,\n            descriptors: {\n              ...exists.descriptors\n            }\n          };\n          if (!atrule) {\n            continue;\n          }\n          current.prelude = atrule.prelude ? appendOrSet(current.prelude, atrule.prelude) : current.prelude || null;\n          for (const [descriptorName, descriptorValue] of Object.entries(atrule.descriptors || {})) {\n            current.descriptors[descriptorName] = descriptorValue ? appendOrSet(current.descriptors[descriptorName], descriptorValue) : null;\n          }\n          if (!Object.keys(current.descriptors).length) {\n            current.descriptors = null;\n          }\n        }\n        break;\n      case 'types':\n      case 'properties':\n        result[prop] = {\n          ...dest[prop]\n        };\n        for (const [name, syntax] of Object.entries(value)) {\n          result[prop][name] = appendOrSet(result[prop][name], syntax);\n        }\n        break;\n      case 'scope':\n        result[prop] = {\n          ...dest[prop]\n        };\n        for (const [name, props] of Object.entries(value)) {\n          result[prop][name] = {\n            ...result[prop][name],\n            ...props\n          };\n        }\n        break;\n      case 'parseContext':\n        result[prop] = {\n          ...dest[prop],\n          ...value\n        };\n        break;\n      case 'atrule':\n      case 'pseudo':\n        result[prop] = {\n          ...dest[prop],\n          ...sliceProps(value, ['parse'])\n        };\n        break;\n      case 'node':\n        result[prop] = {\n          ...dest[prop],\n          ...sliceProps(value, ['name', 'structure', 'parse', 'generate', 'walkContext'])\n        };\n        break;\n    }\n  }\n  return result;\n}\nmodule.exports = mix;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}