{"ast":null,"code":"'use strict';\n\nconst {\n  visit,\n  visitSkip,\n  detachNodeFromParent\n} = require('../lib/xast.js');\nconst {\n  collectStylesheet,\n  computeStyle\n} = require('../lib/style.js');\nconst {\n  hasScripts\n} = require('../lib/svgo/tools.js');\nconst {\n  elemsGroups\n} = require('./_collections.js');\nexports.name = 'removeUselessStrokeAndFill';\nexports.description = 'removes useless stroke and fill attributes';\n\n/**\n * Remove useless stroke and fill attrs.\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'removeUselessStrokeAndFill'>}\n */\nexports.fn = (root, params) => {\n  const {\n    stroke: removeStroke = true,\n    fill: removeFill = true,\n    removeNone = false\n  } = params;\n\n  // style and script elements deoptimise this plugin\n  let hasStyleOrScript = false;\n  visit(root, {\n    element: {\n      enter: node => {\n        if (node.name === 'style' || hasScripts(node)) {\n          hasStyleOrScript = true;\n        }\n      }\n    }\n  });\n  if (hasStyleOrScript) {\n    return null;\n  }\n  const stylesheet = collectStylesheet(root);\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // id attribute deoptimise the whole subtree\n        if (node.attributes.id != null) {\n          return visitSkip;\n        }\n        if (!elemsGroups.shape.has(node.name)) {\n          return;\n        }\n        const computedStyle = computeStyle(stylesheet, node);\n        const stroke = computedStyle.stroke;\n        const strokeOpacity = computedStyle['stroke-opacity'];\n        const strokeWidth = computedStyle['stroke-width'];\n        const markerEnd = computedStyle['marker-end'];\n        const fill = computedStyle.fill;\n        const fillOpacity = computedStyle['fill-opacity'];\n        const computedParentStyle = parentNode.type === 'element' ? computeStyle(stylesheet, parentNode) : null;\n        const parentStroke = computedParentStyle == null ? null : computedParentStyle.stroke;\n\n        // remove stroke*\n        if (removeStroke) {\n          if (stroke == null || stroke.type === 'static' && stroke.value == 'none' || strokeOpacity != null && strokeOpacity.type === 'static' && strokeOpacity.value === '0' || strokeWidth != null && strokeWidth.type === 'static' && strokeWidth.value === '0') {\n            // stroke-width may affect the size of marker-end\n            // marker is not visible when stroke-width is 0\n            if (strokeWidth != null && strokeWidth.type === 'static' && strokeWidth.value === '0' || markerEnd == null) {\n              for (const name of Object.keys(node.attributes)) {\n                if (name.startsWith('stroke')) {\n                  delete node.attributes[name];\n                }\n              }\n              // set explicit none to not inherit from parent\n              if (parentStroke != null && parentStroke.type === 'static' && parentStroke.value !== 'none') {\n                node.attributes.stroke = 'none';\n              }\n            }\n          }\n        }\n\n        // remove fill*\n        if (removeFill) {\n          if (fill != null && fill.type === 'static' && fill.value === 'none' || fillOpacity != null && fillOpacity.type === 'static' && fillOpacity.value === '0') {\n            for (const name of Object.keys(node.attributes)) {\n              if (name.startsWith('fill-')) {\n                delete node.attributes[name];\n              }\n            }\n            if (fill == null || fill.type === 'static' && fill.value !== 'none') {\n              node.attributes.fill = 'none';\n            }\n          }\n        }\n        if (removeNone) {\n          if ((stroke == null || node.attributes.stroke === 'none') && (fill != null && fill.type === 'static' && fill.value === 'none' || node.attributes.fill === 'none')) {\n            detachNodeFromParent(node, parentNode);\n          }\n        }\n      }\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}