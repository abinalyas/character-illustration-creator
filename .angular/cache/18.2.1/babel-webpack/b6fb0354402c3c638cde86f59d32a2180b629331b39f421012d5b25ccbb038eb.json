{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types').XastChild} XastChild\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastParent} XastParent\n */\nconst {\n  elemsGroups\n} = require('./_collections.js');\nconst {\n  visit,\n  visitSkip,\n  querySelector,\n  detachNodeFromParent\n} = require('../lib/xast.js');\nconst {\n  collectStylesheet,\n  computeStyle\n} = require('../lib/style.js');\nconst {\n  parsePathData\n} = require('../lib/path.js');\nconst {\n  hasScripts,\n  findReferences\n} = require('../lib/svgo/tools.js');\nconst nonRendering = elemsGroups.nonRendering;\nexports.name = 'removeHiddenElems';\nexports.description = 'removes hidden elements (zero sized, with absent attributes)';\n\n/**\n * Remove hidden elements with disabled rendering:\n * - display=\"none\"\n * - opacity=\"0\"\n * - circle with zero radius\n * - ellipse with zero x-axis or y-axis radius\n * - rectangle with zero width or height\n * - pattern with zero width or height\n * - image with zero width or height\n * - path with empty data\n * - polyline with empty points\n * - polygon with empty points\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'removeHiddenElems'>}\n */\nexports.fn = (root, params) => {\n  const {\n    isHidden = true,\n    displayNone = true,\n    opacity0 = true,\n    circleR0 = true,\n    ellipseRX0 = true,\n    ellipseRY0 = true,\n    rectWidth0 = true,\n    rectHeight0 = true,\n    patternWidth0 = true,\n    patternHeight0 = true,\n    imageWidth0 = true,\n    imageHeight0 = true,\n    pathEmptyD = true,\n    polylineEmptyPoints = true,\n    polygonEmptyPoints = true\n  } = params;\n  const stylesheet = collectStylesheet(root);\n\n  /**\n   * Skip non-rendered nodes initially, and only detach if they have no ID, or\n   * their ID is not referenced by another node.\n   *\n   * @type {Map<XastElement, XastParent>}\n   */\n  const nonRenderedNodes = new Map();\n\n  /**\n   * IDs for removed hidden definitions.\n   *\n   * @type {Set<string>}\n   */\n  const removedDefIds = new Set();\n\n  /**\n   * @type {Map<XastElement, XastParent>}\n   */\n  const allDefs = new Map();\n\n  /** @type {Set<string>} */\n  const allReferences = new Set();\n\n  /**\n   * @type {Map<string, Array<{ node: XastElement, parentNode: XastParent }>>}\n   */\n  const referencesById = new Map();\n\n  /**\n   * If styles are present, we can't be sure if a definition is unused or not\n   */\n  let deoptimized = false;\n\n  /**\n   * @param {XastChild} node\n   * @param {XastParent} parentNode\n   */\n  function removeElement(node, parentNode) {\n    if (node.type === 'element' && node.attributes.id != null && parentNode.type === 'element' && parentNode.name === 'defs') {\n      removedDefIds.add(node.attributes.id);\n    }\n    detachNodeFromParent(node, parentNode);\n  }\n  visit(root, {\n    element: {\n      enter: (node, parentNode) => {\n        // transparent non-rendering elements still apply where referenced\n        if (nonRendering.has(node.name)) {\n          if (node.attributes.id == null) {\n            detachNodeFromParent(node, parentNode);\n            return visitSkip;\n          }\n          nonRenderedNodes.set(node, parentNode);\n          return visitSkip;\n        }\n        const computedStyle = computeStyle(stylesheet, node);\n        // opacity=\"0\"\n        //\n        // https://www.w3.org/TR/SVG11/masking.html#ObjectAndGroupOpacityProperties\n        if (opacity0 && computedStyle.opacity && computedStyle.opacity.type === 'static' && computedStyle.opacity.value === '0') {\n          removeElement(node, parentNode);\n        }\n      }\n    }\n  });\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        if (node.name === 'style' && node.children.length !== 0 || hasScripts(node)) {\n          deoptimized = true;\n          return;\n        }\n        if (node.name === 'defs') {\n          allDefs.set(node, parentNode);\n        }\n        if (node.name === 'use') {\n          for (const attr of Object.keys(node.attributes)) {\n            if (attr !== 'href' && !attr.endsWith(':href')) continue;\n            const value = node.attributes[attr];\n            const id = value.slice(1);\n            let refs = referencesById.get(id);\n            if (!refs) {\n              refs = [];\n              referencesById.set(id, refs);\n            }\n            refs.push({\n              node,\n              parentNode\n            });\n          }\n        }\n\n        // Removes hidden elements\n        // https://www.w3schools.com/cssref/pr_class_visibility.asp\n        const computedStyle = computeStyle(stylesheet, node);\n        if (isHidden && computedStyle.visibility && computedStyle.visibility.type === 'static' && computedStyle.visibility.value === 'hidden' &&\n        // keep if any descendant enables visibility\n        querySelector(node, '[visibility=visible]') == null) {\n          removeElement(node, parentNode);\n          return;\n        }\n\n        // display=\"none\"\n        //\n        // https://www.w3.org/TR/SVG11/painting.html#DisplayProperty\n        // \"A value of display: none indicates that the given element\n        // and its children shall not be rendered directly\"\n        if (displayNone && computedStyle.display && computedStyle.display.type === 'static' && computedStyle.display.value === 'none' &&\n        // markers with display: none still rendered\n        node.name !== 'marker') {\n          removeElement(node, parentNode);\n          return;\n        }\n\n        // Circles with zero radius\n        //\n        // https://www.w3.org/TR/SVG11/shapes.html#CircleElementRAttribute\n        // \"A value of zero disables rendering of the element\"\n        //\n        // <circle r=\"0\">\n        if (circleR0 && node.name === 'circle' && node.children.length === 0 && node.attributes.r === '0') {\n          removeElement(node, parentNode);\n          return;\n        }\n\n        // Ellipse with zero x-axis radius\n        //\n        // https://www.w3.org/TR/SVG11/shapes.html#EllipseElementRXAttribute\n        // \"A value of zero disables rendering of the element\"\n        //\n        // <ellipse rx=\"0\">\n        if (ellipseRX0 && node.name === 'ellipse' && node.children.length === 0 && node.attributes.rx === '0') {\n          removeElement(node, parentNode);\n          return;\n        }\n\n        // Ellipse with zero y-axis radius\n        //\n        // https://www.w3.org/TR/SVG11/shapes.html#EllipseElementRYAttribute\n        // \"A value of zero disables rendering of the element\"\n        //\n        // <ellipse ry=\"0\">\n        if (ellipseRY0 && node.name === 'ellipse' && node.children.length === 0 && node.attributes.ry === '0') {\n          removeElement(node, parentNode);\n          return;\n        }\n\n        // Rectangle with zero width\n        //\n        // https://www.w3.org/TR/SVG11/shapes.html#RectElementWidthAttribute\n        // \"A value of zero disables rendering of the element\"\n        //\n        // <rect width=\"0\">\n        if (rectWidth0 && node.name === 'rect' && node.children.length === 0 && node.attributes.width === '0') {\n          removeElement(node, parentNode);\n          return;\n        }\n\n        // Rectangle with zero height\n        //\n        // https://www.w3.org/TR/SVG11/shapes.html#RectElementHeightAttribute\n        // \"A value of zero disables rendering of the element\"\n        //\n        // <rect height=\"0\">\n        if (rectHeight0 && rectWidth0 && node.name === 'rect' && node.children.length === 0 && node.attributes.height === '0') {\n          removeElement(node, parentNode);\n          return;\n        }\n\n        // Pattern with zero width\n        //\n        // https://www.w3.org/TR/SVG11/pservers.html#PatternElementWidthAttribute\n        // \"A value of zero disables rendering of the element (i.e., no paint is applied)\"\n        //\n        // <pattern width=\"0\">\n        if (patternWidth0 && node.name === 'pattern' && node.attributes.width === '0') {\n          removeElement(node, parentNode);\n          return;\n        }\n\n        // Pattern with zero height\n        //\n        // https://www.w3.org/TR/SVG11/pservers.html#PatternElementHeightAttribute\n        // \"A value of zero disables rendering of the element (i.e., no paint is applied)\"\n        //\n        // <pattern height=\"0\">\n        if (patternHeight0 && node.name === 'pattern' && node.attributes.height === '0') {\n          removeElement(node, parentNode);\n          return;\n        }\n\n        // Image with zero width\n        //\n        // https://www.w3.org/TR/SVG11/struct.html#ImageElementWidthAttribute\n        // \"A value of zero disables rendering of the element\"\n        //\n        // <image width=\"0\">\n        if (imageWidth0 && node.name === 'image' && node.attributes.width === '0') {\n          removeElement(node, parentNode);\n          return;\n        }\n\n        // Image with zero height\n        //\n        // https://www.w3.org/TR/SVG11/struct.html#ImageElementHeightAttribute\n        // \"A value of zero disables rendering of the element\"\n        //\n        // <image height=\"0\">\n        if (imageHeight0 && node.name === 'image' && node.attributes.height === '0') {\n          removeElement(node, parentNode);\n          return;\n        }\n\n        // Path with empty data\n        //\n        // https://www.w3.org/TR/SVG11/paths.html#DAttribute\n        //\n        // <path d=\"\"/>\n        if (pathEmptyD && node.name === 'path') {\n          if (node.attributes.d == null) {\n            removeElement(node, parentNode);\n            return;\n          }\n          const pathData = parsePathData(node.attributes.d);\n          if (pathData.length === 0) {\n            removeElement(node, parentNode);\n            return;\n          }\n          // keep single point paths for markers\n          if (pathData.length === 1 && computedStyle['marker-start'] == null && computedStyle['marker-end'] == null) {\n            removeElement(node, parentNode);\n            return;\n          }\n        }\n\n        // Polyline with empty points\n        //\n        // https://www.w3.org/TR/SVG11/shapes.html#PolylineElementPointsAttribute\n        //\n        // <polyline points=\"\">\n        if (polylineEmptyPoints && node.name === 'polyline' && node.attributes.points == null) {\n          removeElement(node, parentNode);\n          return;\n        }\n\n        // Polygon with empty points\n        //\n        // https://www.w3.org/TR/SVG11/shapes.html#PolygonElementPointsAttribute\n        //\n        // <polygon points=\"\">\n        if (polygonEmptyPoints && node.name === 'polygon' && node.attributes.points == null) {\n          removeElement(node, parentNode);\n          return;\n        }\n        for (const [name, value] of Object.entries(node.attributes)) {\n          const ids = findReferences(name, value);\n          for (const id of ids) {\n            allReferences.add(id);\n          }\n        }\n      }\n    },\n    root: {\n      exit: () => {\n        for (const id of removedDefIds) {\n          const refs = referencesById.get(id);\n          if (refs) {\n            for (const {\n              node,\n              parentNode\n            } of refs) {\n              detachNodeFromParent(node, parentNode);\n            }\n          }\n        }\n        if (!deoptimized) {\n          for (const [nonRenderedNode, nonRenderedParent] of nonRenderedNodes.entries()) {\n            const id = nonRenderedNode.attributes.id;\n            if (!allReferences.has(id)) {\n              detachNodeFromParent(nonRenderedNode, nonRenderedParent);\n            }\n          }\n        }\n        for (const [node, parentNode] of allDefs.entries()) {\n          if (node.children.length === 0) {\n            detachNodeFromParent(node, parentNode);\n          }\n        }\n      }\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}