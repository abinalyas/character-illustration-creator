{"ast":null,"code":"'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\nconst charCodeDefinitions = require('../../tokenizer/char-code-definitions.cjs');\nconst PLUSSIGN = 0x002B; // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\nconst QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)\n\nfunction eatHexSequence(offset, allowDash) {\n  let len = 0;\n  for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {\n    const code = this.charCodeAt(pos);\n    if (code === HYPHENMINUS && allowDash && len !== 0) {\n      eatHexSequence.call(this, offset + len + 1, false);\n      return -1;\n    }\n    if (!charCodeDefinitions.isHexDigit(code)) {\n      this.error(allowDash && len !== 0 ? 'Hyphen minus' + (len < 6 ? ' or hex digit' : '') + ' is expected' : len < 6 ? 'Hex digit is expected' : 'Unexpected input', pos);\n    }\n    if (++len > 6) {\n      this.error('Too many hex digits', pos);\n    }\n  }\n  this.next();\n  return len;\n}\nfunction eatQuestionMarkSequence(max) {\n  let count = 0;\n  while (this.isDelim(QUESTIONMARK)) {\n    if (++count > max) {\n      this.error('Too many question marks');\n    }\n    this.next();\n  }\n}\nfunction startsWith(code) {\n  if (this.charCodeAt(this.tokenStart) !== code) {\n    this.error((code === PLUSSIGN ? 'Plus sign' : 'Hyphen minus') + ' is expected');\n  }\n}\n\n// https://drafts.csswg.org/css-syntax/#urange\n// Informally, the <urange> production has three forms:\n// U+0001\n//      Defines a range consisting of a single code point, in this case the code point \"1\".\n// U+0001-00ff\n//      Defines a range of codepoints between the first and the second value, in this case\n//      the range between \"1\" and \"ff\" (255 in decimal) inclusive.\n// U+00??\n//      Defines a range of codepoints where the \"?\" characters range over all hex digits,\n//      in this case defining the same as the value U+0000-00ff.\n// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat \"?\" as a hexadecimal digit).\n//\n// <urange> =\n//   u '+' <ident-token> '?'* |\n//   u <dimension-token> '?'* |\n//   u <number-token> '?'* |\n//   u <number-token> <dimension-token> |\n//   u <number-token> <number-token> |\n//   u '+' '?'+\nfunction scanUnicodeRange() {\n  let hexLength = 0;\n  switch (this.tokenType) {\n    case types.Number:\n      // u <number-token> '?'*\n      // u <number-token> <dimension-token>\n      // u <number-token> <number-token>\n      hexLength = eatHexSequence.call(this, 1, true);\n      if (this.isDelim(QUESTIONMARK)) {\n        eatQuestionMarkSequence.call(this, 6 - hexLength);\n        break;\n      }\n      if (this.tokenType === types.Dimension || this.tokenType === types.Number) {\n        startsWith.call(this, HYPHENMINUS);\n        eatHexSequence.call(this, 1, false);\n        break;\n      }\n      break;\n    case types.Dimension:\n      // u <dimension-token> '?'*\n      hexLength = eatHexSequence.call(this, 1, true);\n      if (hexLength > 0) {\n        eatQuestionMarkSequence.call(this, 6 - hexLength);\n      }\n      break;\n    default:\n      // u '+' <ident-token> '?'*\n      // u '+' '?'+\n      this.eatDelim(PLUSSIGN);\n      if (this.tokenType === types.Ident) {\n        hexLength = eatHexSequence.call(this, 0, true);\n        if (hexLength > 0) {\n          eatQuestionMarkSequence.call(this, 6 - hexLength);\n        }\n        break;\n      }\n      if (this.isDelim(QUESTIONMARK)) {\n        this.next();\n        eatQuestionMarkSequence.call(this, 5);\n        break;\n      }\n      this.error('Hex digit or question mark is expected');\n  }\n}\nconst name = 'UnicodeRange';\nconst structure = {\n  value: String\n};\nfunction parse() {\n  const start = this.tokenStart;\n\n  // U or u\n  this.eatIdent('u');\n  scanUnicodeRange.call(this);\n  return {\n    type: 'UnicodeRange',\n    loc: this.getLocation(start, this.tokenStart),\n    value: this.substrToCursor(start)\n  };\n}\nfunction generate(node) {\n  this.tokenize(node.value);\n}\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}