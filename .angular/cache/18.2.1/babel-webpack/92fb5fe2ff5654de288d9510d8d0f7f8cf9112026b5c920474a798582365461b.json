{"ast":null,"code":"'use strict';\n\nconst types = require('../../tokenizer/types.cjs');\nconst charCodeDefinitions = require('../../tokenizer/char-code-definitions.cjs');\nconst PLUSSIGN = 0x002B; // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\nconst N = 0x006E; // U+006E LATIN SMALL LETTER N (n)\nconst DISALLOW_SIGN = true;\nconst ALLOW_SIGN = false;\nfunction checkInteger(offset, disallowSign) {\n  let pos = this.tokenStart + offset;\n  const code = this.charCodeAt(pos);\n  if (code === PLUSSIGN || code === HYPHENMINUS) {\n    if (disallowSign) {\n      this.error('Number sign is not allowed');\n    }\n    pos++;\n  }\n  for (; pos < this.tokenEnd; pos++) {\n    if (!charCodeDefinitions.isDigit(this.charCodeAt(pos))) {\n      this.error('Integer is expected', pos);\n    }\n  }\n}\nfunction checkTokenIsInteger(disallowSign) {\n  return checkInteger.call(this, 0, disallowSign);\n}\nfunction expectCharCode(offset, code) {\n  if (!this.cmpChar(this.tokenStart + offset, code)) {\n    let msg = '';\n    switch (code) {\n      case N:\n        msg = 'N is expected';\n        break;\n      case HYPHENMINUS:\n        msg = 'HyphenMinus is expected';\n        break;\n    }\n    this.error(msg, this.tokenStart + offset);\n  }\n}\n\n// ... <signed-integer>\n// ... ['+' | '-'] <signless-integer>\nfunction consumeB() {\n  let offset = 0;\n  let sign = 0;\n  let type = this.tokenType;\n  while (type === types.WhiteSpace || type === types.Comment) {\n    type = this.lookupType(++offset);\n  }\n  if (type !== types.Number) {\n    if (this.isDelim(PLUSSIGN, offset) || this.isDelim(HYPHENMINUS, offset)) {\n      sign = this.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;\n      do {\n        type = this.lookupType(++offset);\n      } while (type === types.WhiteSpace || type === types.Comment);\n      if (type !== types.Number) {\n        this.skip(offset);\n        checkTokenIsInteger.call(this, DISALLOW_SIGN);\n      }\n    } else {\n      return null;\n    }\n  }\n  if (offset > 0) {\n    this.skip(offset);\n  }\n  if (sign === 0) {\n    type = this.charCodeAt(this.tokenStart);\n    if (type !== PLUSSIGN && type !== HYPHENMINUS) {\n      this.error('Number sign is expected');\n    }\n  }\n  checkTokenIsInteger.call(this, sign !== 0);\n  return sign === HYPHENMINUS ? '-' + this.consume(types.Number) : this.consume(types.Number);\n}\n\n// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb\nconst name = 'AnPlusB';\nconst structure = {\n  a: [String, null],\n  b: [String, null]\n};\nfunction parse() {\n  /* eslint-disable brace-style*/\n  const start = this.tokenStart;\n  let a = null;\n  let b = null;\n\n  // <integer>\n  if (this.tokenType === types.Number) {\n    checkTokenIsInteger.call(this, ALLOW_SIGN);\n    b = this.consume(types.Number);\n  }\n\n  // -n\n  // -n <signed-integer>\n  // -n ['+' | '-'] <signless-integer>\n  // -n- <signless-integer>\n  // <dashndashdigit-ident>\n  else if (this.tokenType === types.Ident && this.cmpChar(this.tokenStart, HYPHENMINUS)) {\n    a = '-1';\n    expectCharCode.call(this, 1, N);\n    switch (this.tokenEnd - this.tokenStart) {\n      // -n\n      // -n <signed-integer>\n      // -n ['+' | '-'] <signless-integer>\n      case 2:\n        this.next();\n        b = consumeB.call(this);\n        break;\n\n      // -n- <signless-integer>\n      case 3:\n        expectCharCode.call(this, 2, HYPHENMINUS);\n        this.next();\n        this.skipSC();\n        checkTokenIsInteger.call(this, DISALLOW_SIGN);\n        b = '-' + this.consume(types.Number);\n        break;\n\n      // <dashndashdigit-ident>\n      default:\n        expectCharCode.call(this, 2, HYPHENMINUS);\n        checkInteger.call(this, 3, DISALLOW_SIGN);\n        this.next();\n        b = this.substrToCursor(start + 2);\n    }\n  }\n\n  // '+'? n\n  // '+'? n <signed-integer>\n  // '+'? n ['+' | '-'] <signless-integer>\n  // '+'? n- <signless-integer>\n  // '+'? <ndashdigit-ident>\n  else if (this.tokenType === types.Ident || this.isDelim(PLUSSIGN) && this.lookupType(1) === types.Ident) {\n    let sign = 0;\n    a = '1';\n\n    // just ignore a plus\n    if (this.isDelim(PLUSSIGN)) {\n      sign = 1;\n      this.next();\n    }\n    expectCharCode.call(this, 0, N);\n    switch (this.tokenEnd - this.tokenStart) {\n      // '+'? n\n      // '+'? n <signed-integer>\n      // '+'? n ['+' | '-'] <signless-integer>\n      case 1:\n        this.next();\n        b = consumeB.call(this);\n        break;\n\n      // '+'? n- <signless-integer>\n      case 2:\n        expectCharCode.call(this, 1, HYPHENMINUS);\n        this.next();\n        this.skipSC();\n        checkTokenIsInteger.call(this, DISALLOW_SIGN);\n        b = '-' + this.consume(types.Number);\n        break;\n\n      // '+'? <ndashdigit-ident>\n      default:\n        expectCharCode.call(this, 1, HYPHENMINUS);\n        checkInteger.call(this, 2, DISALLOW_SIGN);\n        this.next();\n        b = this.substrToCursor(start + sign + 1);\n    }\n  }\n\n  // <ndashdigit-dimension>\n  // <ndash-dimension> <signless-integer>\n  // <n-dimension>\n  // <n-dimension> <signed-integer>\n  // <n-dimension> ['+' | '-'] <signless-integer>\n  else if (this.tokenType === types.Dimension) {\n    const code = this.charCodeAt(this.tokenStart);\n    const sign = code === PLUSSIGN || code === HYPHENMINUS;\n    let i = this.tokenStart + sign;\n    for (; i < this.tokenEnd; i++) {\n      if (!charCodeDefinitions.isDigit(this.charCodeAt(i))) {\n        break;\n      }\n    }\n    if (i === this.tokenStart + sign) {\n      this.error('Integer is expected', this.tokenStart + sign);\n    }\n    expectCharCode.call(this, i - this.tokenStart, N);\n    a = this.substring(start, i);\n\n    // <n-dimension>\n    // <n-dimension> <signed-integer>\n    // <n-dimension> ['+' | '-'] <signless-integer>\n    if (i + 1 === this.tokenEnd) {\n      this.next();\n      b = consumeB.call(this);\n    } else {\n      expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS);\n\n      // <ndash-dimension> <signless-integer>\n      if (i + 2 === this.tokenEnd) {\n        this.next();\n        this.skipSC();\n        checkTokenIsInteger.call(this, DISALLOW_SIGN);\n        b = '-' + this.consume(types.Number);\n      }\n      // <ndashdigit-dimension>\n      else {\n        checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);\n        this.next();\n        b = this.substrToCursor(i + 1);\n      }\n    }\n  } else {\n    this.error();\n  }\n  if (a !== null && a.charCodeAt(0) === PLUSSIGN) {\n    a = a.substr(1);\n  }\n  if (b !== null && b.charCodeAt(0) === PLUSSIGN) {\n    b = b.substr(1);\n  }\n  return {\n    type: 'AnPlusB',\n    loc: this.getLocation(start, this.tokenStart),\n    a,\n    b\n  };\n}\nfunction generate(node) {\n  if (node.a) {\n    const a = node.a === '+1' && 'n' || node.a === '1' && 'n' || node.a === '-1' && '-n' || node.a + 'n';\n    if (node.b) {\n      const b = node.b[0] === '-' || node.b[0] === '+' ? node.b : '+' + node.b;\n      this.tokenize(a + b);\n    } else {\n      this.tokenize(a);\n    }\n  } else {\n    this.tokenize(node.b);\n  }\n}\nexports.generate = generate;\nexports.name = name;\nexports.parse = parse;\nexports.structure = structure;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}