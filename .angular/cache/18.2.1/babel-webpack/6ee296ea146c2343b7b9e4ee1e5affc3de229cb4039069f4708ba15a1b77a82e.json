{"ast":null,"code":"'use strict';\n\nconst {\n  hasOwnProperty\n} = Object.prototype;\nconst shape = {\n  generic: true,\n  types: appendOrAssign,\n  atrules: {\n    prelude: appendOrAssignOrNull,\n    descriptors: appendOrAssignOrNull\n  },\n  properties: appendOrAssign,\n  parseContext: assign,\n  scope: deepAssign,\n  atrule: ['parse'],\n  pseudo: ['parse'],\n  node: ['name', 'structure', 'parse', 'generate', 'walkContext']\n};\nfunction isObject(value) {\n  return value && value.constructor === Object;\n}\nfunction copy(value) {\n  return isObject(value) ? {\n    ...value\n  } : value;\n}\nfunction assign(dest, src) {\n  return Object.assign(dest, src);\n}\nfunction deepAssign(dest, src) {\n  for (const key in src) {\n    if (hasOwnProperty.call(src, key)) {\n      if (isObject(dest[key])) {\n        deepAssign(dest[key], src[key]);\n      } else {\n        dest[key] = copy(src[key]);\n      }\n    }\n  }\n  return dest;\n}\nfunction append(a, b) {\n  if (typeof b === 'string' && /^\\s*\\|/.test(b)) {\n    return typeof a === 'string' ? a + b : b.replace(/^\\s*\\|\\s*/, '');\n  }\n  return b || null;\n}\nfunction appendOrAssign(a, b) {\n  if (typeof b === 'string') {\n    return append(a, b);\n  }\n  const result = {\n    ...a\n  };\n  for (let key in b) {\n    if (hasOwnProperty.call(b, key)) {\n      result[key] = append(hasOwnProperty.call(a, key) ? a[key] : undefined, b[key]);\n    }\n  }\n  return result;\n}\nfunction appendOrAssignOrNull(a, b) {\n  const result = appendOrAssign(a, b);\n  return !isObject(result) || Object.keys(result).length ? result : null;\n}\nfunction mix(dest, src, shape) {\n  for (const key in shape) {\n    if (hasOwnProperty.call(shape, key) === false) {\n      continue;\n    }\n    if (shape[key] === true) {\n      if (hasOwnProperty.call(src, key)) {\n        dest[key] = copy(src[key]);\n      }\n    } else if (shape[key]) {\n      if (typeof shape[key] === 'function') {\n        const fn = shape[key];\n        dest[key] = fn({}, dest[key]);\n        dest[key] = fn(dest[key] || {}, src[key]);\n      } else if (isObject(shape[key])) {\n        const result = {};\n        for (let name in dest[key]) {\n          result[name] = mix({}, dest[key][name], shape[key]);\n        }\n        for (let name in src[key]) {\n          result[name] = mix(result[name] || {}, src[key][name], shape[key]);\n        }\n        dest[key] = result;\n      } else if (Array.isArray(shape[key])) {\n        const res = {};\n        const innerShape = shape[key].reduce(function (s, k) {\n          s[k] = true;\n          return s;\n        }, {});\n        for (const [name, value] of Object.entries(dest[key] || {})) {\n          res[name] = {};\n          if (value) {\n            mix(res[name], value, innerShape);\n          }\n        }\n        for (const name in src[key]) {\n          if (hasOwnProperty.call(src[key], name)) {\n            if (!res[name]) {\n              res[name] = {};\n            }\n            if (src[key] && src[key][name]) {\n              mix(res[name], src[key][name], innerShape);\n            }\n          }\n        }\n        dest[key] = res;\n      }\n    }\n  }\n  return dest;\n}\nconst mix$1 = (dest, src) => mix(dest, src, shape);\nmodule.exports = mix$1;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}