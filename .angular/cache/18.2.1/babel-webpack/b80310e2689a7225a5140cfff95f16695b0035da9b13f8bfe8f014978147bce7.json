{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import(\"../lib/types\").PathDataItem} PathDataItem\n * @typedef {import('../lib/types').XastChild} XastChild\n * @typedef {import('../lib/types').XastElement} XastElement\n */\nconst {\n  collectStylesheet,\n  computeStyle\n} = require('../lib/style.js');\nconst {\n  path2js,\n  js2path,\n  intersects\n} = require('./_path.js');\nexports.name = 'mergePaths';\nexports.description = 'merges multiple paths in one if possible';\n\n/**\n * Merge multiple Paths into one.\n *\n * @author Kir Belevich, Lev Solntsev\n *\n * @type {import('./plugins-types').Plugin<'mergePaths'>}\n */\nexports.fn = (root, params) => {\n  const {\n    force = false,\n    floatPrecision,\n    noSpaceAfterFlags = false // a20 60 45 0 1 30 20 â†’ a20 60 45 0130 20\n  } = params;\n  const stylesheet = collectStylesheet(root);\n  return {\n    element: {\n      enter: node => {\n        if (node.children.length <= 1) {\n          return;\n        }\n\n        /** @type {XastChild[]} */\n        const elementsToRemove = [];\n        let prevChild = node.children[0];\n        let prevPathData = null;\n\n        /**\n         * @param {XastElement} child\n         * @param {PathDataItem[]} pathData\n         */\n        const updatePreviousPath = (child, pathData) => {\n          js2path(child, pathData, {\n            floatPrecision,\n            noSpaceAfterFlags\n          });\n          prevPathData = null;\n        };\n        for (let i = 1; i < node.children.length; i++) {\n          const child = node.children[i];\n          if (prevChild.type !== 'element' || prevChild.name !== 'path' || prevChild.children.length !== 0 || prevChild.attributes.d == null) {\n            if (prevPathData && prevChild.type === 'element') {\n              updatePreviousPath(prevChild, prevPathData);\n            }\n            prevChild = child;\n            continue;\n          }\n          if (child.type !== 'element' || child.name !== 'path' || child.children.length !== 0 || child.attributes.d == null) {\n            if (prevPathData) {\n              updatePreviousPath(prevChild, prevPathData);\n            }\n            prevChild = child;\n            continue;\n          }\n          const computedStyle = computeStyle(stylesheet, child);\n          if (computedStyle['marker-start'] || computedStyle['marker-mid'] || computedStyle['marker-end']) {\n            if (prevPathData) {\n              updatePreviousPath(prevChild, prevPathData);\n            }\n            prevChild = child;\n            continue;\n          }\n          const childAttrs = Object.keys(child.attributes);\n          if (childAttrs.length !== Object.keys(prevChild.attributes).length) {\n            if (prevPathData) {\n              updatePreviousPath(prevChild, prevPathData);\n            }\n            prevChild = child;\n            continue;\n          }\n          const areAttrsEqual = childAttrs.some(attr => {\n            return attr !== 'd' && prevChild.type === 'element' && prevChild.attributes[attr] !== child.attributes[attr];\n          });\n          if (areAttrsEqual) {\n            if (prevPathData) {\n              updatePreviousPath(prevChild, prevPathData);\n            }\n            prevChild = child;\n            continue;\n          }\n          const hasPrevPath = prevPathData != null;\n          const currentPathData = path2js(child);\n          prevPathData = prevPathData ?? path2js(prevChild);\n          if (force || !intersects(prevPathData, currentPathData)) {\n            prevPathData.push(...currentPathData);\n            elementsToRemove.push(child);\n            continue;\n          }\n          if (hasPrevPath) {\n            updatePreviousPath(prevChild, prevPathData);\n          }\n          prevChild = child;\n          prevPathData = null;\n        }\n        if (prevPathData && prevChild.type === 'element') {\n          updatePreviousPath(prevChild, prevPathData);\n        }\n        node.children = node.children.filter(child => !elementsToRemove.includes(child));\n      }\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}