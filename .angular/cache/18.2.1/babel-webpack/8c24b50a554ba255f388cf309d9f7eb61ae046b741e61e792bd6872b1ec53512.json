{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastParent} XastParent\n */\nconst {\n  attrsGroupsDefaults,\n  colorsProps\n} = require('./_collections');\nconst {\n  detachNodeFromParent,\n  querySelectorAll,\n  querySelector\n} = require('../lib/xast');\nconst {\n  computeStyle,\n  collectStylesheet\n} = require('../lib/style');\nexports.name = 'convertOneStopGradients';\nexports.description = 'converts one-stop (single color) gradients to a plain color';\n\n/**\n * Converts one-stop (single color) gradients to a plain color.\n *\n * @author Seth Falco <seth@falco.fun>\n * @type {import('./plugins-types').Plugin<'convertOneStopGradients'>}\n * @see https://developer.mozilla.org/docs/Web/SVG/Element/linearGradient\n * @see https://developer.mozilla.org/docs/Web/SVG/Element/radialGradient\n */\nexports.fn = root => {\n  const stylesheet = collectStylesheet(root);\n\n  /**\n   * Parent defs that had gradients elements removed from them.\n   *\n   * @type {Set<XastElement>}\n   */\n  const effectedDefs = new Set();\n\n  /**\n   * @type {Map<XastElement, XastParent>}\n   */\n  const allDefs = new Map();\n\n  /**\n   * @type {Map<XastElement, XastParent>}\n   */\n  const gradientsToDetach = new Map();\n\n  /** Number of references to the xlink:href attribute. */\n  let xlinkHrefCount = 0;\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        if (node.attributes['xlink:href'] != null) {\n          xlinkHrefCount++;\n        }\n        if (node.name === 'defs') {\n          allDefs.set(node, parentNode);\n          return;\n        }\n        if (node.name !== 'linearGradient' && node.name !== 'radialGradient') {\n          return;\n        }\n        const stops = node.children.filter(child => {\n          return child.type === 'element' && child.name === 'stop';\n        });\n        const href = node.attributes['xlink:href'] || node.attributes['href'];\n        let effectiveNode = stops.length === 0 && href != null && href.startsWith('#') ? querySelector(root, href) : node;\n        if (effectiveNode == null || effectiveNode.type !== 'element') {\n          gradientsToDetach.set(node, parentNode);\n          return;\n        }\n        const effectiveStops = effectiveNode.children.filter(child => {\n          return child.type === 'element' && child.name === 'stop';\n        });\n        if (effectiveStops.length !== 1 || effectiveStops[0].type !== 'element') {\n          return;\n        }\n        if (parentNode.type === 'element' && parentNode.name === 'defs') {\n          effectedDefs.add(parentNode);\n        }\n        gradientsToDetach.set(node, parentNode);\n        let color;\n        const style = computeStyle(stylesheet, effectiveStops[0])['stop-color'];\n        if (style != null && style.type === 'static') {\n          color = style.value;\n        }\n        const selectorVal = `url(#${node.attributes.id})`;\n        const selector = [...colorsProps].map(attr => `[${attr}=\"${selectorVal}\"]`).join(',');\n        const elements = querySelectorAll(root, selector);\n        for (const element of elements) {\n          if (element.type !== 'element') {\n            continue;\n          }\n          for (const attr of colorsProps) {\n            if (element.attributes[attr] !== selectorVal) {\n              continue;\n            }\n            if (color != null) {\n              element.attributes[attr] = color;\n            } else {\n              delete element.attributes[attr];\n            }\n          }\n        }\n        const styledElements = querySelectorAll(root, `[style*=${selectorVal}]`);\n        for (const element of styledElements) {\n          if (element.type !== 'element') {\n            continue;\n          }\n          element.attributes.style = element.attributes.style.replace(selectorVal, color || attrsGroupsDefaults.presentation['stop-color']);\n        }\n      },\n      exit: node => {\n        if (node.name === 'svg') {\n          for (const [gradient, parent] of gradientsToDetach.entries()) {\n            if (gradient.attributes['xlink:href'] != null) {\n              xlinkHrefCount--;\n            }\n            detachNodeFromParent(gradient, parent);\n          }\n          if (xlinkHrefCount === 0) {\n            delete node.attributes['xmlns:xlink'];\n          }\n          for (const [defs, parent] of allDefs.entries()) {\n            if (effectedDefs.has(defs) && defs.children.length === 0) {\n              detachNodeFromParent(defs, parent);\n            }\n          }\n        }\n      }\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}