{"ast":null,"code":"'use strict';\n\nconst List = require('../utils/List.cjs');\nconst SyntaxError = require('./SyntaxError.cjs');\nconst index = require('../tokenizer/index.cjs');\nconst sequence = require('./sequence.cjs');\nconst OffsetToLocation = require('../tokenizer/OffsetToLocation.cjs');\nconst TokenStream = require('../tokenizer/TokenStream.cjs');\nconst utils = require('../tokenizer/utils.cjs');\nconst types = require('../tokenizer/types.cjs');\nconst names = require('../tokenizer/names.cjs');\nconst NOOP = () => {};\nconst EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)\nconst NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)\nconst SEMICOLON = 0x003B; // U+003B SEMICOLON (;)\nconst LEFTCURLYBRACKET = 0x007B; // U+007B LEFT CURLY BRACKET ({)\nconst NULL = 0;\nfunction createParseContext(name) {\n  return function () {\n    return this[name]();\n  };\n}\nfunction fetchParseValues(dict) {\n  const result = Object.create(null);\n  for (const name in dict) {\n    const item = dict[name];\n    const fn = item.parse || item;\n    if (fn) {\n      result[name] = fn;\n    }\n  }\n  return result;\n}\nfunction processConfig(config) {\n  const parseConfig = {\n    context: Object.create(null),\n    scope: Object.assign(Object.create(null), config.scope),\n    atrule: fetchParseValues(config.atrule),\n    pseudo: fetchParseValues(config.pseudo),\n    node: fetchParseValues(config.node)\n  };\n  for (const name in config.parseContext) {\n    switch (typeof config.parseContext[name]) {\n      case 'function':\n        parseConfig.context[name] = config.parseContext[name];\n        break;\n      case 'string':\n        parseConfig.context[name] = createParseContext(config.parseContext[name]);\n        break;\n    }\n  }\n  return {\n    config: parseConfig,\n    ...parseConfig,\n    ...parseConfig.node\n  };\n}\nfunction createParser(config) {\n  let source = '';\n  let filename = '<unknown>';\n  let needPositions = false;\n  let onParseError = NOOP;\n  let onParseErrorThrow = false;\n  const locationMap = new OffsetToLocation.OffsetToLocation();\n  const parser = Object.assign(new TokenStream.TokenStream(), processConfig(config || {}), {\n    parseAtrulePrelude: true,\n    parseRulePrelude: true,\n    parseValue: true,\n    parseCustomProperty: false,\n    readSequence: sequence.readSequence,\n    consumeUntilBalanceEnd: () => 0,\n    consumeUntilLeftCurlyBracket(code) {\n      return code === LEFTCURLYBRACKET ? 1 : 0;\n    },\n    consumeUntilLeftCurlyBracketOrSemicolon(code) {\n      return code === LEFTCURLYBRACKET || code === SEMICOLON ? 1 : 0;\n    },\n    consumeUntilExclamationMarkOrSemicolon(code) {\n      return code === EXCLAMATIONMARK || code === SEMICOLON ? 1 : 0;\n    },\n    consumeUntilSemicolonIncluded(code) {\n      return code === SEMICOLON ? 2 : 0;\n    },\n    createList() {\n      return new List.List();\n    },\n    createSingleNodeList(node) {\n      return new List.List().appendData(node);\n    },\n    getFirstListNode(list) {\n      return list && list.first;\n    },\n    getLastListNode(list) {\n      return list && list.last;\n    },\n    parseWithFallback(consumer, fallback) {\n      const startToken = this.tokenIndex;\n      try {\n        return consumer.call(this);\n      } catch (e) {\n        if (onParseErrorThrow) {\n          throw e;\n        }\n        const fallbackNode = fallback.call(this, startToken);\n        onParseErrorThrow = true;\n        onParseError(e, fallbackNode);\n        onParseErrorThrow = false;\n        return fallbackNode;\n      }\n    },\n    lookupNonWSType(offset) {\n      let type;\n      do {\n        type = this.lookupType(offset++);\n        if (type !== types.WhiteSpace) {\n          return type;\n        }\n      } while (type !== NULL);\n      return NULL;\n    },\n    charCodeAt(offset) {\n      return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;\n    },\n    substring(offsetStart, offsetEnd) {\n      return source.substring(offsetStart, offsetEnd);\n    },\n    substrToCursor(start) {\n      return this.source.substring(start, this.tokenStart);\n    },\n    cmpChar(offset, charCode) {\n      return utils.cmpChar(source, offset, charCode);\n    },\n    cmpStr(offsetStart, offsetEnd, str) {\n      return utils.cmpStr(source, offsetStart, offsetEnd, str);\n    },\n    consume(tokenType) {\n      const start = this.tokenStart;\n      this.eat(tokenType);\n      return this.substrToCursor(start);\n    },\n    consumeFunctionName() {\n      const name = source.substring(this.tokenStart, this.tokenEnd - 1);\n      this.eat(types.Function);\n      return name;\n    },\n    consumeNumber(type) {\n      const number = source.substring(this.tokenStart, utils.consumeNumber(source, this.tokenStart));\n      this.eat(type);\n      return number;\n    },\n    eat(tokenType) {\n      if (this.tokenType !== tokenType) {\n        const tokenName = names[tokenType].slice(0, -6).replace(/-/g, ' ').replace(/^./, m => m.toUpperCase());\n        let message = `${/[[\\](){}]/.test(tokenName) ? `\"${tokenName}\"` : tokenName} is expected`;\n        let offset = this.tokenStart;\n\n        // tweak message and offset\n        switch (tokenType) {\n          case types.Ident:\n            // when identifier is expected but there is a function or url\n            if (this.tokenType === types.Function || this.tokenType === types.Url) {\n              offset = this.tokenEnd - 1;\n              message = 'Identifier is expected but function found';\n            } else {\n              message = 'Identifier is expected';\n            }\n            break;\n          case types.Hash:\n            if (this.isDelim(NUMBERSIGN)) {\n              this.next();\n              offset++;\n              message = 'Name is expected';\n            }\n            break;\n          case types.Percentage:\n            if (this.tokenType === types.Number) {\n              offset = this.tokenEnd;\n              message = 'Percent sign is expected';\n            }\n            break;\n        }\n        this.error(message, offset);\n      }\n      this.next();\n    },\n    eatIdent(name) {\n      if (this.tokenType !== types.Ident || this.lookupValue(0, name) === false) {\n        this.error(`Identifier \"${name}\" is expected`);\n      }\n      this.next();\n    },\n    eatDelim(code) {\n      if (!this.isDelim(code)) {\n        this.error(`Delim \"${String.fromCharCode(code)}\" is expected`);\n      }\n      this.next();\n    },\n    getLocation(start, end) {\n      if (needPositions) {\n        return locationMap.getLocationRange(start, end, filename);\n      }\n      return null;\n    },\n    getLocationFromList(list) {\n      if (needPositions) {\n        const head = this.getFirstListNode(list);\n        const tail = this.getLastListNode(list);\n        return locationMap.getLocationRange(head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart, tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart, filename);\n      }\n      return null;\n    },\n    error(message, offset) {\n      const location = typeof offset !== 'undefined' && offset < source.length ? locationMap.getLocation(offset) : this.eof ? locationMap.getLocation(utils.findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);\n      throw new SyntaxError.SyntaxError(message || 'Unexpected input', source, location.offset, location.line, location.column);\n    }\n  });\n  const parse = function (source_, options) {\n    source = source_;\n    options = options || {};\n    parser.setSource(source, index.tokenize);\n    locationMap.setSource(source, options.offset, options.line, options.column);\n    filename = options.filename || '<unknown>';\n    needPositions = Boolean(options.positions);\n    onParseError = typeof options.onParseError === 'function' ? options.onParseError : NOOP;\n    onParseErrorThrow = false;\n    parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;\n    parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;\n    parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;\n    parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;\n    const {\n      context = 'default',\n      onComment\n    } = options;\n    if (context in parser.context === false) {\n      throw new Error('Unknown context `' + context + '`');\n    }\n    if (typeof onComment === 'function') {\n      parser.forEachToken((type, start, end) => {\n        if (type === types.Comment) {\n          const loc = parser.getLocation(start, end);\n          const value = utils.cmpStr(source, end - 2, end, '*/') ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);\n          onComment(value, loc);\n        }\n      });\n    }\n    const ast = parser.context[context].call(parser, options);\n    if (!parser.eof) {\n      parser.error();\n    }\n    return ast;\n  };\n  return Object.assign(parse, {\n    SyntaxError: SyntaxError.SyntaxError,\n    config: parser.config\n  });\n}\nexports.createParser = createParser;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}