{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types.js').PluginInfo} PluginInfo\n * @typedef {import('../lib/types').XastElement} XastElement\n */\nconst csstree = require('css-tree');\nconst {\n  referencesProps\n} = require('./_collections.js');\nexports.name = 'prefixIds';\nexports.description = 'prefix IDs';\n\n/**\n * extract basename from path\n * @type {(path: string) => string}\n */\nconst getBasename = path => {\n  // extract everything after latest slash or backslash\n  const matched = /[/\\\\]?([^/\\\\]+)$/.exec(path);\n  if (matched) {\n    return matched[1];\n  }\n  return '';\n};\n\n/**\n * escapes a string for being used as ID\n * @type {(string: string) => string}\n */\nconst escapeIdentifierName = str => {\n  return str.replace(/[. ]/g, '_');\n};\n\n/**\n * @type {(string: string) => string}\n */\nconst unquote = string => {\n  if (string.startsWith('\"') && string.endsWith('\"') || string.startsWith(\"'\") && string.endsWith(\"'\")) {\n    return string.slice(1, -1);\n  }\n  return string;\n};\n\n/**\n * Prefix the given string, unless it already starts with the generated prefix.\n *\n * @param {(id: string) => string} prefixGenerator Function to generate a prefix.\n * @param {string} body An arbitrary string.\n * @returns {string} The given string with a prefix prepended to it.\n */\nconst prefixId = (prefixGenerator, body) => {\n  const prefix = prefixGenerator(body);\n  if (body.startsWith(prefix)) {\n    return body;\n  }\n  return prefix + body;\n};\n\n/**\n * Insert the prefix in a reference string. A reference string is already\n * prefixed with #, so the prefix is inserted after the first character.\n *\n * @param {(id: string) => string} prefixGenerator Function to generate a prefix.\n * @param {string} reference An arbitrary string, should start with \"#\".\n * @returns {?string} The given string with a prefix inserted, or null if the string did not start with \"#\".\n */\nconst prefixReference = (prefixGenerator, reference) => {\n  if (reference.startsWith('#')) {\n    return '#' + prefixId(prefixGenerator, reference.slice(1));\n  }\n  return null;\n};\n\n/**\n * Generates a prefix for the given string.\n *\n * @param {string} body An arbitrary string.\n * @param {XastElement} node XML node that the identifier belongs to.\n * @param {PluginInfo} info\n * @param {((node: XastElement, info: PluginInfo) => string)|string|boolean|undefined} prefixGenerator Some way of obtaining a prefix.\n * @param {string} delim Content to insert between the prefix and original value.\n * @param {Map<string, string>} history Map of previously generated prefixes to IDs.\n * @returns {string} A generated prefix.\n */\nconst generatePrefix = (body, node, info, prefixGenerator, delim, history) => {\n  if (typeof prefixGenerator === 'function') {\n    let prefix = history.get(body);\n    if (prefix != null) {\n      return prefix;\n    }\n    prefix = prefixGenerator(node, info) + delim;\n    history.set(body, prefix);\n    return prefix;\n  }\n  if (typeof prefixGenerator === 'string') {\n    return prefixGenerator + delim;\n  }\n  if (prefixGenerator === false) {\n    return '';\n  }\n  if (info.path != null && info.path.length > 0) {\n    return escapeIdentifierName(getBasename(info.path)) + delim;\n  }\n  return 'prefix' + delim;\n};\n\n/**\n * Prefixes identifiers\n *\n * @author strarsis <strarsis@gmail.com>\n * @type {import('./plugins-types').Plugin<'prefixIds'>}\n */\nexports.fn = (_root, params, info) => {\n  const {\n    delim = '__',\n    prefix,\n    prefixIds = true,\n    prefixClassNames = true\n  } = params;\n\n  /** @type {Map<string, string>} */\n  const prefixMap = new Map();\n  return {\n    element: {\n      enter: node => {\n        /**\n         * @param {string} id A node identifier or class.\n         * @returns {string} Given string with a prefix inserted, or null if the string did not start with \"#\".\n         */\n        const prefixGenerator = id => generatePrefix(id, node, info, prefix, delim, prefixMap);\n\n        // prefix id/class selectors and url() references in styles\n        if (node.name === 'style') {\n          // skip empty <style/> elements\n          if (node.children.length === 0) {\n            return;\n          }\n          for (const child of node.children) {\n            if (child.type !== 'text' && child.type !== 'cdata') {\n              continue;\n            }\n            const cssText = child.value;\n            /** @type {?csstree.CssNode} */\n            let cssAst = null;\n            try {\n              cssAst = csstree.parse(cssText, {\n                parseValue: true,\n                parseCustomProperty: false\n              });\n            } catch {\n              return;\n            }\n            csstree.walk(cssAst, node => {\n              if (prefixIds && node.type === 'IdSelector' || prefixClassNames && node.type === 'ClassSelector') {\n                node.name = prefixId(prefixGenerator, node.name);\n                return;\n              }\n              if (node.type === 'Url' && node.value.length > 0) {\n                const prefixed = prefixReference(prefixGenerator, unquote(node.value));\n                if (prefixed != null) {\n                  node.value = prefixed;\n                }\n              }\n            });\n            child.value = csstree.generate(cssAst);\n            return;\n          }\n        }\n\n        // prefix an ID attribute value\n        if (prefixIds && node.attributes.id != null && node.attributes.id.length !== 0) {\n          node.attributes.id = prefixId(prefixGenerator, node.attributes.id);\n        }\n\n        // prefix a class attribute value\n        if (prefixClassNames && node.attributes.class != null && node.attributes.class.length !== 0) {\n          node.attributes.class = node.attributes.class.split(/\\s+/).map(name => prefixId(prefixGenerator, name)).join(' ');\n        }\n\n        // prefix a href attribute value\n        // xlink:href is deprecated, must be still supported\n        for (const name of ['href', 'xlink:href']) {\n          if (node.attributes[name] != null && node.attributes[name].length !== 0) {\n            const prefixed = prefixReference(prefixGenerator, node.attributes[name]);\n            if (prefixed != null) {\n              node.attributes[name] = prefixed;\n            }\n          }\n        }\n\n        // prefix a URL attribute value\n        for (const name of referencesProps) {\n          if (node.attributes[name] != null && node.attributes[name].length !== 0) {\n            node.attributes[name] = node.attributes[name].replace(/\\burl\\(([\"'])?(#.+?)\\1\\)/gi, (match, _, url) => {\n              const prefixed = prefixReference(prefixGenerator, url);\n              if (prefixed == null) {\n                return match;\n              }\n              return `url(${prefixed})`;\n            });\n          }\n        }\n\n        // prefix begin/end attribute value\n        for (const name of ['begin', 'end']) {\n          if (node.attributes[name] != null && node.attributes[name].length !== 0) {\n            const parts = node.attributes[name].split(/\\s*;\\s+/).map(val => {\n              if (val.endsWith('.end') || val.endsWith('.start')) {\n                const [id, postfix] = val.split('.');\n                return `${prefixId(prefixGenerator, id)}.${postfix}`;\n              }\n              return val;\n            });\n            node.attributes[name] = parts.join('; ');\n          }\n        }\n      }\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}