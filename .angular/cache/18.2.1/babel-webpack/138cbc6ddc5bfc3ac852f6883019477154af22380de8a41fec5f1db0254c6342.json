{"ast":null,"code":"'use strict';\n\nconst cssTree = require('css-tree');\nlet fingerprintId = 1;\nconst dontRestructure = new Set(['src' // https://github.com/afelix/csso/issues/50\n]);\nconst DONT_MIX_VALUE = {\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/display#Browser_compatibility\n  'display': /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,\n  // https://developer.mozilla.org/en/docs/Web/CSS/text-align\n  'text-align': /^(start|end|match-parent|justify-all)$/i\n};\nconst SAFE_VALUES = {\n  cursor: ['auto', 'crosshair', 'default', 'move', 'text', 'wait', 'help', 'n-resize', 'e-resize', 's-resize', 'w-resize', 'ne-resize', 'nw-resize', 'se-resize', 'sw-resize', 'pointer', 'progress', 'not-allowed', 'no-drop', 'vertical-text', 'all-scroll', 'col-resize', 'row-resize'],\n  overflow: ['hidden', 'visible', 'scroll', 'auto'],\n  position: ['static', 'relative', 'absolute', 'fixed']\n};\nconst NEEDLESS_TABLE = {\n  'border-width': ['border'],\n  'border-style': ['border'],\n  'border-color': ['border'],\n  'border-top': ['border'],\n  'border-right': ['border'],\n  'border-bottom': ['border'],\n  'border-left': ['border'],\n  'border-top-width': ['border-top', 'border-width', 'border'],\n  'border-right-width': ['border-right', 'border-width', 'border'],\n  'border-bottom-width': ['border-bottom', 'border-width', 'border'],\n  'border-left-width': ['border-left', 'border-width', 'border'],\n  'border-top-style': ['border-top', 'border-style', 'border'],\n  'border-right-style': ['border-right', 'border-style', 'border'],\n  'border-bottom-style': ['border-bottom', 'border-style', 'border'],\n  'border-left-style': ['border-left', 'border-style', 'border'],\n  'border-top-color': ['border-top', 'border-color', 'border'],\n  'border-right-color': ['border-right', 'border-color', 'border'],\n  'border-bottom-color': ['border-bottom', 'border-color', 'border'],\n  'border-left-color': ['border-left', 'border-color', 'border'],\n  'margin-top': ['margin'],\n  'margin-right': ['margin'],\n  'margin-bottom': ['margin'],\n  'margin-left': ['margin'],\n  'padding-top': ['padding'],\n  'padding-right': ['padding'],\n  'padding-bottom': ['padding'],\n  'padding-left': ['padding'],\n  'font-style': ['font'],\n  'font-variant': ['font'],\n  'font-weight': ['font'],\n  'font-size': ['font'],\n  'font-family': ['font'],\n  'list-style-type': ['list-style'],\n  'list-style-position': ['list-style'],\n  'list-style-image': ['list-style']\n};\nfunction getPropertyFingerprint(propertyName, declaration, fingerprints) {\n  const realName = cssTree.property(propertyName).basename;\n  if (realName === 'background') {\n    return propertyName + ':' + cssTree.generate(declaration.value);\n  }\n  const declarationId = declaration.id;\n  let fingerprint = fingerprints[declarationId];\n  if (!fingerprint) {\n    switch (declaration.value.type) {\n      case 'Value':\n        const special = {};\n        let vendorId = '';\n        let iehack = '';\n        let raw = false;\n        declaration.value.children.forEach(function walk(node) {\n          switch (node.type) {\n            case 'Value':\n            case 'Brackets':\n            case 'Parentheses':\n              node.children.forEach(walk);\n              break;\n            case 'Raw':\n              raw = true;\n              break;\n            case 'Identifier':\n              {\n                const {\n                  name\n                } = node;\n                if (!vendorId) {\n                  vendorId = cssTree.keyword(name).vendor;\n                }\n                if (/\\\\[09]/.test(name)) {\n                  iehack = RegExp.lastMatch;\n                }\n                if (SAFE_VALUES.hasOwnProperty(realName)) {\n                  if (SAFE_VALUES[realName].indexOf(name) === -1) {\n                    special[name] = true;\n                  }\n                } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {\n                  if (DONT_MIX_VALUE[realName].test(name)) {\n                    special[name] = true;\n                  }\n                }\n                break;\n              }\n            case 'Function':\n              {\n                let {\n                  name\n                } = node;\n                if (!vendorId) {\n                  vendorId = cssTree.keyword(name).vendor;\n                }\n                if (name === 'rect') {\n                  // there are 2 forms of rect:\n                  //   rect(<top>, <right>, <bottom>, <left>) - standart\n                  //   rect(<top> <right> <bottom> <left>) â€“ backwards compatible syntax\n                  // only the same form values can be merged\n                  const hasComma = node.children.some(node => node.type === 'Operator' && node.value === ',');\n                  if (!hasComma) {\n                    name = 'rect-backward';\n                  }\n                }\n                special[name + '()'] = true;\n\n                // check nested tokens too\n                node.children.forEach(walk);\n                break;\n              }\n            case 'Dimension':\n              {\n                const {\n                  unit\n                } = node;\n                if (/\\\\[09]/.test(unit)) {\n                  iehack = RegExp.lastMatch;\n                }\n                switch (unit) {\n                  // is not supported until IE11\n                  case 'rem':\n\n                  // v* units is too buggy across browsers and better\n                  // don't merge values with those units\n                  case 'vw':\n                  case 'vh':\n                  case 'vmin':\n                  case 'vmax':\n                  case 'vm':\n                    // IE9 supporting \"vm\" instead of \"vmin\".\n                    special[unit] = true;\n                    break;\n                }\n                break;\n              }\n          }\n        });\n        fingerprint = raw ? '!' + fingerprintId++ : '!' + Object.keys(special).sort() + '|' + iehack + vendorId;\n        break;\n      case 'Raw':\n        fingerprint = '!' + declaration.value.value;\n        break;\n      default:\n        fingerprint = cssTree.generate(declaration.value);\n    }\n    fingerprints[declarationId] = fingerprint;\n  }\n  return propertyName + fingerprint;\n}\nfunction needless(props, declaration, fingerprints) {\n  const property = cssTree.property(declaration.property);\n  if (NEEDLESS_TABLE.hasOwnProperty(property.basename)) {\n    const table = NEEDLESS_TABLE[property.basename];\n    for (const entry of table) {\n      const ppre = getPropertyFingerprint(property.prefix + entry, declaration, fingerprints);\n      const prev = props.hasOwnProperty(ppre) ? props[ppre] : null;\n      if (prev && (!declaration.important || prev.item.data.important)) {\n        return prev;\n      }\n    }\n  }\n}\nfunction processRule(rule, item, list, props, fingerprints) {\n  const declarations = rule.block.children;\n  declarations.forEachRight(function (declaration, declarationItem) {\n    const {\n      property\n    } = declaration;\n    const fingerprint = getPropertyFingerprint(property, declaration, fingerprints);\n    const prev = props[fingerprint];\n    if (prev && !dontRestructure.has(property)) {\n      if (declaration.important && !prev.item.data.important) {\n        props[fingerprint] = {\n          block: declarations,\n          item: declarationItem\n        };\n        prev.block.remove(prev.item);\n\n        // TODO: use it when we can refer to several points in source\n        // declaration.loc = {\n        //     primary: declaration.loc,\n        //     merged: prev.item.data.loc\n        // };\n      } else {\n        declarations.remove(declarationItem);\n\n        // TODO: use it when we can refer to several points in source\n        // prev.item.data.loc = {\n        //     primary: prev.item.data.loc,\n        //     merged: declaration.loc\n        // };\n      }\n    } else {\n      const prev = needless(props, declaration, fingerprints);\n      if (prev) {\n        declarations.remove(declarationItem);\n\n        // TODO: use it when we can refer to several points in source\n        // prev.item.data.loc = {\n        //     primary: prev.item.data.loc,\n        //     merged: declaration.loc\n        // };\n      } else {\n        declaration.fingerprint = fingerprint;\n        props[fingerprint] = {\n          block: declarations,\n          item: declarationItem\n        };\n      }\n    }\n  });\n  if (declarations.isEmpty) {\n    list.remove(item);\n  }\n}\nfunction restructBlock(ast) {\n  const stylesheetMap = {};\n  const fingerprints = Object.create(null);\n  cssTree.walk(ast, {\n    visit: 'Rule',\n    reverse: true,\n    enter(node, item, list) {\n      const stylesheet = this.block || this.stylesheet;\n      const ruleId = (node.pseudoSignature || '') + '|' + node.prelude.children.first.id;\n      let ruleMap;\n      let props;\n      if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {\n        ruleMap = {};\n        stylesheetMap[stylesheet.id] = ruleMap;\n      } else {\n        ruleMap = stylesheetMap[stylesheet.id];\n      }\n      if (ruleMap.hasOwnProperty(ruleId)) {\n        props = ruleMap[ruleId];\n      } else {\n        props = {};\n        ruleMap[ruleId] = props;\n      }\n      processRule.call(this, node, item, list, props, fingerprints);\n    }\n  });\n}\nmodule.exports = restructBlock;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}