{"ast":null,"code":"'use strict';\n\nconst charCodeDefinitions = require('../tokenizer/char-code-definitions.cjs');\nconst utils = require('../tokenizer/utils.cjs');\nconst REVERSE_SOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\\)\n\nfunction decode(str) {\n  const end = str.length - 1;\n  let decoded = '';\n  for (let i = 0; i < str.length; i++) {\n    let code = str.charCodeAt(i);\n    if (code === REVERSE_SOLIDUS) {\n      // special case at the ending\n      if (i === end) {\n        // if the next input code point is EOF, do nothing\n        break;\n      }\n      code = str.charCodeAt(++i);\n\n      // consume escaped\n      if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {\n        const escapeStart = i - 1;\n        const escapeEnd = utils.consumeEscaped(str, escapeStart);\n        i = escapeEnd - 1;\n        decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));\n      } else {\n        // \\r\\n\n        if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {\n          i++;\n        }\n      }\n    } else {\n      decoded += str[i];\n    }\n  }\n  return decoded;\n}\n\n// https://drafts.csswg.org/cssom/#serialize-an-identifier\n// ยง 2.1. Common Serializing Idioms\nfunction encode(str) {\n  let encoded = '';\n\n  // If the character is the first character and is a \"-\" (U+002D),\n  // and there is no second character, then the escaped character.\n  // Note: That's means a single dash string \"-\" return as escaped dash,\n  // so move the condition out of the main loop\n  if (str.length === 1 && str.charCodeAt(0) === 0x002D) {\n    return '\\\\-';\n  }\n\n  // To serialize an identifier means to create a string represented\n  // by the concatenation of, for each character of the identifier:\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i);\n\n    // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).\n    if (code === 0x0000) {\n      encoded += '\\uFFFD';\n      continue;\n    }\n    if (\n    // If the character is in the range [\\1-\\1f] (U+0001 to U+001F) or is U+007F ...\n    // Note: Do not compare with 0x0001 since 0x0000 is precessed before\n    code <= 0x001F || code === 0x007F ||\n    // [or] ... is in the range [0-9] (U+0030 to U+0039),\n    code >= 0x0030 && code <= 0x0039 && (\n    // If the character is the first character ...\n    i === 0 ||\n    // If the character is the second character ... and the first character is a \"-\" (U+002D)\n    i === 1 && str.charCodeAt(0) === 0x002D)) {\n      // ... then the character escaped as code point.\n      encoded += '\\\\' + code.toString(16) + ' ';\n      continue;\n    }\n\n    // If the character is not handled by one of the above rules and is greater\n    // than or equal to U+0080, is \"-\" (U+002D) or \"_\" (U+005F), or is in one\n    // of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to U+005A),\n    // or \\[a-z] (U+0061 to U+007A), then the character itself.\n    if (charCodeDefinitions.isName(code)) {\n      encoded += str.charAt(i);\n    } else {\n      // Otherwise, the escaped character.\n      encoded += '\\\\' + str.charAt(i);\n    }\n  }\n  return encoded;\n}\nexports.decode = decode;\nexports.encode = encode;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}