{"ast":null,"code":"'use strict';\n\nconst charCodeDefinitions = require('../tokenizer/char-code-definitions.cjs');\nconst types = require('../tokenizer/types.cjs');\nconst utils = require('../tokenizer/utils.cjs');\nconst PLUSSIGN = 0x002B; // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\nconst QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)\nconst U = 0x0075; // U+0075 LATIN SMALL LETTER U (u)\n\nfunction isDelim(token, code) {\n  return token !== null && token.type === types.Delim && token.value.charCodeAt(0) === code;\n}\nfunction startsWith(token, code) {\n  return token.value.charCodeAt(0) === code;\n}\nfunction hexSequence(token, offset, allowDash) {\n  let hexlen = 0;\n  for (let pos = offset; pos < token.value.length; pos++) {\n    const code = token.value.charCodeAt(pos);\n    if (code === HYPHENMINUS && allowDash && hexlen !== 0) {\n      hexSequence(token, offset + hexlen + 1, false);\n      return 6; // dissallow following question marks\n    }\n    if (!charCodeDefinitions.isHexDigit(code)) {\n      return 0; // not a hex digit\n    }\n    if (++hexlen > 6) {\n      return 0; // too many hex digits\n    }\n  }\n  return hexlen;\n}\nfunction withQuestionMarkSequence(consumed, length, getNextToken) {\n  if (!consumed) {\n    return 0; // nothing consumed\n  }\n  while (isDelim(getNextToken(length), QUESTIONMARK)) {\n    if (++consumed > 6) {\n      return 0; // too many question marks\n    }\n    length++;\n  }\n  return length;\n}\n\n// https://drafts.csswg.org/css-syntax/#urange\n// Informally, the <urange> production has three forms:\n// U+0001\n//      Defines a range consisting of a single code point, in this case the code point \"1\".\n// U+0001-00ff\n//      Defines a range of codepoints between the first and the second value, in this case\n//      the range between \"1\" and \"ff\" (255 in decimal) inclusive.\n// U+00??\n//      Defines a range of codepoints where the \"?\" characters range over all hex digits,\n//      in this case defining the same as the value U+0000-00ff.\n// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat \"?\" as a hexadecimal digit).\n//\n// <urange> =\n//   u '+' <ident-token> '?'* |\n//   u <dimension-token> '?'* |\n//   u <number-token> '?'* |\n//   u <number-token> <dimension-token> |\n//   u <number-token> <number-token> |\n//   u '+' '?'+\nfunction urange(token, getNextToken) {\n  let length = 0;\n\n  // should start with `u` or `U`\n  if (token === null || token.type !== types.Ident || !utils.cmpChar(token.value, 0, U)) {\n    return 0;\n  }\n  token = getNextToken(++length);\n  if (token === null) {\n    return 0;\n  }\n\n  // u '+' <ident-token> '?'*\n  // u '+' '?'+\n  if (isDelim(token, PLUSSIGN)) {\n    token = getNextToken(++length);\n    if (token === null) {\n      return 0;\n    }\n    if (token.type === types.Ident) {\n      // u '+' <ident-token> '?'*\n      return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);\n    }\n    if (isDelim(token, QUESTIONMARK)) {\n      // u '+' '?'+\n      return withQuestionMarkSequence(1, ++length, getNextToken);\n    }\n\n    // Hex digit or question mark is expected\n    return 0;\n  }\n\n  // u <number-token> '?'*\n  // u <number-token> <dimension-token>\n  // u <number-token> <number-token>\n  if (token.type === types.Number) {\n    const consumedHexLength = hexSequence(token, 1, true);\n    if (consumedHexLength === 0) {\n      return 0;\n    }\n    token = getNextToken(++length);\n    if (token === null) {\n      // u <number-token> <eof>\n      return length;\n    }\n    if (token.type === types.Dimension || token.type === types.Number) {\n      // u <number-token> <dimension-token>\n      // u <number-token> <number-token>\n      if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {\n        return 0;\n      }\n      return length + 1;\n    }\n\n    // u <number-token> '?'*\n    return withQuestionMarkSequence(consumedHexLength, length, getNextToken);\n  }\n\n  // u <dimension-token> '?'*\n  if (token.type === types.Dimension) {\n    return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);\n  }\n  return 0;\n}\nmodule.exports = urange;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}