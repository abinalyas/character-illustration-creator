{"ast":null,"code":"'use strict';\n\nconst {\n  removeLeadingZero,\n  toFixed\n} = require('./svgo/tools');\n\n/**\n * @typedef {import('./types').PathDataItem} PathDataItem\n * @typedef {import('./types').PathDataCommand} PathDataCommand\n */\n\n// Based on https://www.w3.org/TR/SVG11/paths.html#PathDataBNF\n\nconst argsCountPerCommand = {\n  M: 2,\n  m: 2,\n  Z: 0,\n  z: 0,\n  L: 2,\n  l: 2,\n  H: 1,\n  h: 1,\n  V: 1,\n  v: 1,\n  C: 6,\n  c: 6,\n  S: 4,\n  s: 4,\n  Q: 4,\n  q: 4,\n  T: 2,\n  t: 2,\n  A: 7,\n  a: 7\n};\n\n/**\n * @type {(c: string) => c is PathDataCommand}\n */\nconst isCommand = c => {\n  return c in argsCountPerCommand;\n};\n\n/**\n * @type {(c: string) => boolean}\n */\nconst isWsp = c => {\n  const codePoint = c.codePointAt(0);\n  return codePoint === 0x20 || codePoint === 0x9 || codePoint === 0xd || codePoint === 0xa;\n};\n\n/**\n * @type {(c: string) => boolean}\n */\nconst isDigit = c => {\n  const codePoint = c.codePointAt(0);\n  if (codePoint == null) {\n    return false;\n  }\n  return 48 <= codePoint && codePoint <= 57;\n};\n\n/**\n * @typedef {'none' | 'sign' | 'whole' | 'decimal_point' | 'decimal' | 'e' | 'exponent_sign' | 'exponent'} ReadNumberState\n */\n\n/**\n * @type {(string: string, cursor: number) => [number, ?number]}\n */\nconst readNumber = (string, cursor) => {\n  let i = cursor;\n  let value = '';\n  let state = /** @type {ReadNumberState} */'none';\n  for (; i < string.length; i += 1) {\n    const c = string[i];\n    if (c === '+' || c === '-') {\n      if (state === 'none') {\n        state = 'sign';\n        value += c;\n        continue;\n      }\n      if (state === 'e') {\n        state = 'exponent_sign';\n        value += c;\n        continue;\n      }\n    }\n    if (isDigit(c)) {\n      if (state === 'none' || state === 'sign' || state === 'whole') {\n        state = 'whole';\n        value += c;\n        continue;\n      }\n      if (state === 'decimal_point' || state === 'decimal') {\n        state = 'decimal';\n        value += c;\n        continue;\n      }\n      if (state === 'e' || state === 'exponent_sign' || state === 'exponent') {\n        state = 'exponent';\n        value += c;\n        continue;\n      }\n    }\n    if (c === '.') {\n      if (state === 'none' || state === 'sign' || state === 'whole') {\n        state = 'decimal_point';\n        value += c;\n        continue;\n      }\n    }\n    if (c === 'E' || c == 'e') {\n      if (state === 'whole' || state === 'decimal_point' || state === 'decimal') {\n        state = 'e';\n        value += c;\n        continue;\n      }\n    }\n    break;\n  }\n  const number = Number.parseFloat(value);\n  if (Number.isNaN(number)) {\n    return [cursor, null];\n  } else {\n    // step back to delegate iteration to parent loop\n    return [i - 1, number];\n  }\n};\n\n/**\n * @type {(string: string) => PathDataItem[]}\n */\nconst parsePathData = string => {\n  /**\n   * @type {PathDataItem[]}\n   */\n  const pathData = [];\n  /**\n   * @type {?PathDataCommand}\n   */\n  let command = null;\n  let args = /** @type {number[]} */[];\n  let argsCount = 0;\n  let canHaveComma = false;\n  let hadComma = false;\n  for (let i = 0; i < string.length; i += 1) {\n    const c = string.charAt(i);\n    if (isWsp(c)) {\n      continue;\n    }\n    // allow comma only between arguments\n    if (canHaveComma && c === ',') {\n      if (hadComma) {\n        break;\n      }\n      hadComma = true;\n      continue;\n    }\n    if (isCommand(c)) {\n      if (hadComma) {\n        return pathData;\n      }\n      if (command == null) {\n        // moveto should be leading command\n        if (c !== 'M' && c !== 'm') {\n          return pathData;\n        }\n      } else {\n        // stop if previous command arguments are not flushed\n        if (args.length !== 0) {\n          return pathData;\n        }\n      }\n      command = c;\n      args = [];\n      argsCount = argsCountPerCommand[command];\n      canHaveComma = false;\n      // flush command without arguments\n      if (argsCount === 0) {\n        pathData.push({\n          command,\n          args\n        });\n      }\n      continue;\n    }\n    // avoid parsing arguments if no command detected\n    if (command == null) {\n      return pathData;\n    }\n    // read next argument\n    let newCursor = i;\n    let number = null;\n    if (command === 'A' || command === 'a') {\n      const position = args.length;\n      if (position === 0 || position === 1) {\n        // allow only positive number without sign as first two arguments\n        if (c !== '+' && c !== '-') {\n          [newCursor, number] = readNumber(string, i);\n        }\n      }\n      if (position === 2 || position === 5 || position === 6) {\n        [newCursor, number] = readNumber(string, i);\n      }\n      if (position === 3 || position === 4) {\n        // read flags\n        if (c === '0') {\n          number = 0;\n        }\n        if (c === '1') {\n          number = 1;\n        }\n      }\n    } else {\n      [newCursor, number] = readNumber(string, i);\n    }\n    if (number == null) {\n      return pathData;\n    }\n    args.push(number);\n    canHaveComma = true;\n    hadComma = false;\n    i = newCursor;\n    // flush arguments when necessary count is reached\n    if (args.length === argsCount) {\n      pathData.push({\n        command,\n        args\n      });\n      // subsequent moveto coordinates are treated as implicit lineto commands\n      if (command === 'M') {\n        command = 'L';\n      }\n      if (command === 'm') {\n        command = 'l';\n      }\n      args = [];\n    }\n  }\n  return pathData;\n};\nexports.parsePathData = parsePathData;\n\n/**\n * @type {(number: number, precision?: number) => {\n *   roundedStr: string,\n *   rounded: number\n * }}\n */\nconst roundAndStringify = (number, precision) => {\n  if (precision != null) {\n    number = toFixed(number, precision);\n  }\n  return {\n    roundedStr: removeLeadingZero(number),\n    rounded: number\n  };\n};\n\n/**\n * Elliptical arc large-arc and sweep flags are rendered with spaces\n * because many non-browser environments are not able to parse such paths\n *\n * @type {(\n *   command: string,\n *   args: number[],\n *   precision?: number,\n *   disableSpaceAfterFlags?: boolean\n * ) => string}\n */\nconst stringifyArgs = (command, args, precision, disableSpaceAfterFlags) => {\n  let result = '';\n  let previous;\n  for (let i = 0; i < args.length; i++) {\n    const {\n      roundedStr,\n      rounded\n    } = roundAndStringify(args[i], precision);\n    if (disableSpaceAfterFlags && (command === 'A' || command === 'a') && (\n    // consider combined arcs\n    i % 7 === 4 || i % 7 === 5)) {\n      result += roundedStr;\n    } else if (i === 0 || rounded < 0) {\n      // avoid space before first and negative numbers\n      result += roundedStr;\n    } else if (!Number.isInteger(previous) && rounded != 0 && rounded < 1 && rounded > -1) {\n      // remove space before decimal with zero whole\n      // only when previous number is also decimal\n      result += roundedStr;\n    } else {\n      result += ` ${roundedStr}`;\n    }\n    previous = rounded;\n  }\n  return result;\n};\n\n/**\n * @typedef {{\n *   pathData: PathDataItem[];\n *   precision?: number;\n *   disableSpaceAfterFlags?: boolean;\n * }} StringifyPathDataOptions\n */\n\n/**\n * @param {StringifyPathDataOptions} options\n * @returns {string}\n */\nconst stringifyPathData = ({\n  pathData,\n  precision,\n  disableSpaceAfterFlags\n}) => {\n  if (pathData.length === 1) {\n    const {\n      command,\n      args\n    } = pathData[0];\n    return command + stringifyArgs(command, args, precision, disableSpaceAfterFlags);\n  }\n  let result = '';\n  let prev = {\n    ...pathData[0]\n  };\n\n  // match leading moveto with following lineto\n  if (pathData[1].command === 'L') {\n    prev.command = 'M';\n  } else if (pathData[1].command === 'l') {\n    prev.command = 'm';\n  }\n  for (let i = 1; i < pathData.length; i++) {\n    const {\n      command,\n      args\n    } = pathData[i];\n    if (prev.command === command && prev.command !== 'M' && prev.command !== 'm' ||\n    // combine matching moveto and lineto sequences\n    prev.command === 'M' && command === 'L' || prev.command === 'm' && command === 'l') {\n      prev.args = [...prev.args, ...args];\n      if (i === pathData.length - 1) {\n        result += prev.command + stringifyArgs(prev.command, prev.args, precision, disableSpaceAfterFlags);\n      }\n    } else {\n      result += prev.command + stringifyArgs(prev.command, prev.args, precision, disableSpaceAfterFlags);\n      if (i === pathData.length - 1) {\n        result += command + stringifyArgs(command, args, precision, disableSpaceAfterFlags);\n      } else {\n        prev = {\n          command,\n          args\n        };\n      }\n    }\n  }\n  return result;\n};\nexports.stringifyPathData = stringifyPathData;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}