{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('./types').XastNode} XastNode\n * @typedef {import('./types').XastInstruction} XastInstruction\n * @typedef {import('./types').XastDoctype} XastDoctype\n * @typedef {import('./types').XastComment} XastComment\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastCdata} XastCdata\n * @typedef {import('./types').XastText} XastText\n * @typedef {import('./types').XastParent} XastParent\n * @typedef {import('./types').XastChild} XastChild\n */\n\n// @ts-ignore sax will be replaced with something else later\nconst SAX = require('@trysound/sax');\nconst {\n  textElems\n} = require('../plugins/_collections');\nclass SvgoParserError extends Error {\n  /**\n   * @param message {string}\n   * @param line {number}\n   * @param column {number}\n   * @param source {string}\n   * @param file {void | string}\n   */\n  constructor(message, line, column, source, file) {\n    super(message);\n    this.name = 'SvgoParserError';\n    this.message = `${file || '<input>'}:${line}:${column}: ${message}`;\n    this.reason = message;\n    this.line = line;\n    this.column = column;\n    this.source = source;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, SvgoParserError);\n    }\n  }\n  toString() {\n    const lines = this.source.split(/\\r?\\n/);\n    const startLine = Math.max(this.line - 3, 0);\n    const endLine = Math.min(this.line + 2, lines.length);\n    const lineNumberWidth = String(endLine).length;\n    const startColumn = Math.max(this.column - 54, 0);\n    const endColumn = Math.max(this.column + 20, 80);\n    const code = lines.slice(startLine, endLine).map((line, index) => {\n      const lineSlice = line.slice(startColumn, endColumn);\n      let ellipsisPrefix = '';\n      let ellipsisSuffix = '';\n      if (startColumn !== 0) {\n        ellipsisPrefix = startColumn > line.length - 1 ? ' ' : '…';\n      }\n      if (endColumn < line.length - 1) {\n        ellipsisSuffix = '…';\n      }\n      const number = startLine + 1 + index;\n      const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;\n      if (number === this.line) {\n        const gutterSpacing = gutter.replace(/[^|]/g, ' ');\n        const lineSpacing = (ellipsisPrefix + line.slice(startColumn, this.column - 1)).replace(/[^\\t]/g, ' ');\n        const spacing = gutterSpacing + lineSpacing;\n        return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}\\n ${spacing}^`;\n      }\n      return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;\n    }).join('\\n');\n    return `${this.name}: ${this.message}\\n\\n${code}\\n`;\n  }\n}\nconst entityDeclaration = /<!ENTITY\\s+(\\S+)\\s+(?:'([^']+)'|\"([^\"]+)\")\\s*>/g;\nconst config = {\n  strict: true,\n  trim: false,\n  normalize: false,\n  lowercase: true,\n  xmlns: true,\n  position: true\n};\n\n/**\n * Convert SVG (XML) string to SVG-as-JS object.\n *\n * @type {(data: string, from?: string) => XastRoot}\n */\nconst parseSvg = (data, from) => {\n  const sax = SAX.parser(config.strict, config);\n  /**\n   * @type {XastRoot}\n   */\n  const root = {\n    type: 'root',\n    children: []\n  };\n  /**\n   * @type {XastParent}\n   */\n  let current = root;\n  /**\n   * @type {XastParent[]}\n   */\n  const stack = [root];\n\n  /**\n   * @type {(node: XastChild) => void}\n   */\n  const pushToContent = node => {\n    // TODO remove legacy parentNode in v4\n    Object.defineProperty(node, 'parentNode', {\n      writable: true,\n      value: current\n    });\n    current.children.push(node);\n  };\n\n  /**\n   * @type {(doctype: string) => void}\n   */\n  sax.ondoctype = doctype => {\n    /**\n     * @type {XastDoctype}\n     */\n    const node = {\n      type: 'doctype',\n      // TODO parse doctype for name, public and system to match xast\n      name: 'svg',\n      data: {\n        doctype\n      }\n    };\n    pushToContent(node);\n    const subsetStart = doctype.indexOf('[');\n    if (subsetStart >= 0) {\n      entityDeclaration.lastIndex = subsetStart;\n      let entityMatch = entityDeclaration.exec(data);\n      while (entityMatch != null) {\n        sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];\n        entityMatch = entityDeclaration.exec(data);\n      }\n    }\n  };\n\n  /**\n   * @type {(data: { name: string, body: string }) => void}\n   */\n  sax.onprocessinginstruction = data => {\n    /**\n     * @type {XastInstruction}\n     */\n    const node = {\n      type: 'instruction',\n      name: data.name,\n      value: data.body\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(comment: string) => void}\n   */\n  sax.oncomment = comment => {\n    /**\n     * @type {XastComment}\n     */\n    const node = {\n      type: 'comment',\n      value: comment.trim()\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(cdata: string) => void}\n   */\n  sax.oncdata = cdata => {\n    /**\n     * @type {XastCdata}\n     */\n    const node = {\n      type: 'cdata',\n      value: cdata\n    };\n    pushToContent(node);\n  };\n\n  /**\n   * @type {(data: { name: string, attributes: Record<string, { value: string }>}) => void}\n   */\n  sax.onopentag = data => {\n    /**\n     * @type {XastElement}\n     */\n    let element = {\n      type: 'element',\n      name: data.name,\n      attributes: {},\n      children: []\n    };\n    for (const [name, attr] of Object.entries(data.attributes)) {\n      element.attributes[name] = attr.value;\n    }\n    pushToContent(element);\n    current = element;\n    stack.push(element);\n  };\n\n  /**\n   * @type {(text: string) => void}\n   */\n  sax.ontext = text => {\n    if (current.type === 'element') {\n      // prevent trimming of meaningful whitespace inside textual tags\n      if (textElems.has(current.name)) {\n        /**\n         * @type {XastText}\n         */\n        const node = {\n          type: 'text',\n          value: text\n        };\n        pushToContent(node);\n      } else if (/\\S/.test(text)) {\n        /**\n         * @type {XastText}\n         */\n        const node = {\n          type: 'text',\n          value: text.trim()\n        };\n        pushToContent(node);\n      }\n    }\n  };\n  sax.onclosetag = () => {\n    stack.pop();\n    current = stack[stack.length - 1];\n  };\n\n  /**\n   * @type {(e: any) => void}\n   */\n  sax.onerror = e => {\n    const error = new SvgoParserError(e.reason, e.line + 1, e.column, data, from);\n    if (e.message.indexOf('Unexpected end') === -1) {\n      throw error;\n    }\n  };\n  sax.write(data).close();\n  return root;\n};\nexports.parseSvg = parseSvg;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}