{"ast":null,"code":"'use strict';\n\nconst {\n  hasOwnProperty\n} = Object.prototype;\nconst noop = function () {};\nfunction ensureFunction(value) {\n  return typeof value === 'function' ? value : noop;\n}\nfunction invokeForType(fn, type) {\n  return function (node, item, list) {\n    if (node.type === type) {\n      fn.call(this, node, item, list);\n    }\n  };\n}\nfunction getWalkersFromStructure(name, nodeType) {\n  const structure = nodeType.structure;\n  const walkers = [];\n  for (const key in structure) {\n    if (hasOwnProperty.call(structure, key) === false) {\n      continue;\n    }\n    let fieldTypes = structure[key];\n    const walker = {\n      name: key,\n      type: false,\n      nullable: false\n    };\n    if (!Array.isArray(fieldTypes)) {\n      fieldTypes = [fieldTypes];\n    }\n    for (const fieldType of fieldTypes) {\n      if (fieldType === null) {\n        walker.nullable = true;\n      } else if (typeof fieldType === 'string') {\n        walker.type = 'node';\n      } else if (Array.isArray(fieldType)) {\n        walker.type = 'list';\n      }\n    }\n    if (walker.type) {\n      walkers.push(walker);\n    }\n  }\n  if (walkers.length) {\n    return {\n      context: nodeType.walkContext,\n      fields: walkers\n    };\n  }\n  return null;\n}\nfunction getTypesFromConfig(config) {\n  const types = {};\n  for (const name in config.node) {\n    if (hasOwnProperty.call(config.node, name)) {\n      const nodeType = config.node[name];\n      if (!nodeType.structure) {\n        throw new Error('Missed `structure` field in `' + name + '` node type definition');\n      }\n      types[name] = getWalkersFromStructure(name, nodeType);\n    }\n  }\n  return types;\n}\nfunction createTypeIterator(config, reverse) {\n  const fields = config.fields.slice();\n  const contextName = config.context;\n  const useContext = typeof contextName === 'string';\n  if (reverse) {\n    fields.reverse();\n  }\n  return function (node, context, walk, walkReducer) {\n    let prevContextValue;\n    if (useContext) {\n      prevContextValue = context[contextName];\n      context[contextName] = node;\n    }\n    for (const field of fields) {\n      const ref = node[field.name];\n      if (!field.nullable || ref) {\n        if (field.type === 'list') {\n          const breakWalk = reverse ? ref.reduceRight(walkReducer, false) : ref.reduce(walkReducer, false);\n          if (breakWalk) {\n            return true;\n          }\n        } else if (walk(ref)) {\n          return true;\n        }\n      }\n    }\n    if (useContext) {\n      context[contextName] = prevContextValue;\n    }\n  };\n}\nfunction createFastTraveralMap({\n  StyleSheet,\n  Atrule,\n  Rule,\n  Block,\n  DeclarationList\n}) {\n  return {\n    Atrule: {\n      StyleSheet,\n      Atrule,\n      Rule,\n      Block\n    },\n    Rule: {\n      StyleSheet,\n      Atrule,\n      Rule,\n      Block\n    },\n    Declaration: {\n      StyleSheet,\n      Atrule,\n      Rule,\n      Block,\n      DeclarationList\n    }\n  };\n}\nfunction createWalker(config) {\n  const types = getTypesFromConfig(config);\n  const iteratorsNatural = {};\n  const iteratorsReverse = {};\n  const breakWalk = Symbol('break-walk');\n  const skipNode = Symbol('skip-node');\n  for (const name in types) {\n    if (hasOwnProperty.call(types, name) && types[name] !== null) {\n      iteratorsNatural[name] = createTypeIterator(types[name], false);\n      iteratorsReverse[name] = createTypeIterator(types[name], true);\n    }\n  }\n  const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);\n  const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);\n  const walk = function (root, options) {\n    function walkNode(node, item, list) {\n      const enterRet = enter.call(context, node, item, list);\n      if (enterRet === breakWalk) {\n        return true;\n      }\n      if (enterRet === skipNode) {\n        return false;\n      }\n      if (iterators.hasOwnProperty(node.type)) {\n        if (iterators[node.type](node, context, walkNode, walkReducer)) {\n          return true;\n        }\n      }\n      if (leave.call(context, node, item, list) === breakWalk) {\n        return true;\n      }\n      return false;\n    }\n    let enter = noop;\n    let leave = noop;\n    let iterators = iteratorsNatural;\n    let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);\n    const context = {\n      break: breakWalk,\n      skip: skipNode,\n      root,\n      stylesheet: null,\n      atrule: null,\n      atrulePrelude: null,\n      rule: null,\n      selector: null,\n      block: null,\n      declaration: null,\n      function: null\n    };\n    if (typeof options === 'function') {\n      enter = options;\n    } else if (options) {\n      enter = ensureFunction(options.enter);\n      leave = ensureFunction(options.leave);\n      if (options.reverse) {\n        iterators = iteratorsReverse;\n      }\n      if (options.visit) {\n        if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {\n          iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];\n        } else if (!types.hasOwnProperty(options.visit)) {\n          throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).sort().join(', ') + ')');\n        }\n        enter = invokeForType(enter, options.visit);\n        leave = invokeForType(leave, options.visit);\n      }\n    }\n    if (enter === noop && leave === noop) {\n      throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\\'t a function');\n    }\n    walkNode(root);\n  };\n  walk.break = breakWalk;\n  walk.skip = skipNode;\n  walk.find = function (ast, fn) {\n    let found = null;\n    walk(ast, function (node, item, list) {\n      if (fn.call(this, node, item, list)) {\n        found = node;\n        return breakWalk;\n      }\n    });\n    return found;\n  };\n  walk.findLast = function (ast, fn) {\n    let found = null;\n    walk(ast, {\n      reverse: true,\n      enter(node, item, list) {\n        if (fn.call(this, node, item, list)) {\n          found = node;\n          return breakWalk;\n        }\n      }\n    });\n    return found;\n  };\n  walk.findAll = function (ast, fn) {\n    const found = [];\n    walk(ast, function (node, item, list) {\n      if (fn.call(this, node, item, list)) {\n        found.push(node);\n      }\n    });\n    return found;\n  };\n  return walk;\n}\nexports.createWalker = createWalker;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}