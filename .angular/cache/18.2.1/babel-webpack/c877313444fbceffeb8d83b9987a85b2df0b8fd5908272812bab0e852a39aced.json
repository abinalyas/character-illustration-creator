{"ast":null,"code":"'use strict';\n\nconst matchGraph = require('./match-graph.cjs');\nconst types = require('../tokenizer/types.cjs');\nconst {\n  hasOwnProperty\n} = Object.prototype;\nconst STUB = 0;\nconst TOKEN = 1;\nconst OPEN_SYNTAX = 2;\nconst CLOSE_SYNTAX = 3;\nconst EXIT_REASON_MATCH = 'Match';\nconst EXIT_REASON_MISMATCH = 'Mismatch';\nconst EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';\nconst ITERATION_LIMIT = 15000;\nfunction reverseList(list) {\n  let prev = null;\n  let next = null;\n  let item = list;\n  while (item !== null) {\n    next = item.prev;\n    item.prev = prev;\n    prev = item;\n    item = next;\n  }\n  return prev;\n}\nfunction areStringsEqualCaseInsensitive(testStr, referenceStr) {\n  if (testStr.length !== referenceStr.length) {\n    return false;\n  }\n  for (let i = 0; i < testStr.length; i++) {\n    const referenceCode = referenceStr.charCodeAt(i);\n    let testCode = testStr.charCodeAt(i);\n\n    // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).\n    if (testCode >= 0x0041 && testCode <= 0x005A) {\n      testCode = testCode | 32;\n    }\n    if (testCode !== referenceCode) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isContextEdgeDelim(token) {\n  if (token.type !== types.Delim) {\n    return false;\n  }\n\n  // Fix matching for unicode-range: U+30??, U+FF00-FF9F\n  // Probably we need to check out previous match instead\n  return token.value !== '?';\n}\nfunction isCommaContextStart(token) {\n  if (token === null) {\n    return true;\n  }\n  return token.type === types.Comma || token.type === types.Function || token.type === types.LeftParenthesis || token.type === types.LeftSquareBracket || token.type === types.LeftCurlyBracket || isContextEdgeDelim(token);\n}\nfunction isCommaContextEnd(token) {\n  if (token === null) {\n    return true;\n  }\n  return token.type === types.RightParenthesis || token.type === types.RightSquareBracket || token.type === types.RightCurlyBracket || token.type === types.Delim && token.value === '/';\n}\nfunction internalMatch(tokens, state, syntaxes) {\n  function moveToNextToken() {\n    do {\n      tokenIndex++;\n      token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n    } while (token !== null && (token.type === types.WhiteSpace || token.type === types.Comment));\n  }\n  function getNextToken(offset) {\n    const nextIndex = tokenIndex + offset;\n    return nextIndex < tokens.length ? tokens[nextIndex] : null;\n  }\n  function stateSnapshotFromSyntax(nextState, prev) {\n    return {\n      nextState,\n      matchStack,\n      syntaxStack,\n      thenStack,\n      tokenIndex,\n      prev\n    };\n  }\n  function pushThenStack(nextState) {\n    thenStack = {\n      nextState,\n      matchStack,\n      syntaxStack,\n      prev: thenStack\n    };\n  }\n  function pushElseStack(nextState) {\n    elseStack = stateSnapshotFromSyntax(nextState, elseStack);\n  }\n  function addTokenToMatch() {\n    matchStack = {\n      type: TOKEN,\n      syntax: state.syntax,\n      token,\n      prev: matchStack\n    };\n    moveToNextToken();\n    syntaxStash = null;\n    if (tokenIndex > longestMatch) {\n      longestMatch = tokenIndex;\n    }\n  }\n  function openSyntax() {\n    syntaxStack = {\n      syntax: state.syntax,\n      opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,\n      prev: syntaxStack\n    };\n    matchStack = {\n      type: OPEN_SYNTAX,\n      syntax: state.syntax,\n      token: matchStack.token,\n      prev: matchStack\n    };\n  }\n  function closeSyntax() {\n    if (matchStack.type === OPEN_SYNTAX) {\n      matchStack = matchStack.prev;\n    } else {\n      matchStack = {\n        type: CLOSE_SYNTAX,\n        syntax: syntaxStack.syntax,\n        token: matchStack.token,\n        prev: matchStack\n      };\n    }\n    syntaxStack = syntaxStack.prev;\n  }\n  let syntaxStack = null;\n  let thenStack = null;\n  let elseStack = null;\n\n  // null – stashing allowed, nothing stashed\n  // false – stashing disabled, nothing stashed\n  // anithing else – fail stashable syntaxes, some syntax stashed\n  let syntaxStash = null;\n  let iterationCount = 0; // count iterations and prevent infinite loop\n  let exitReason = null;\n  let token = null;\n  let tokenIndex = -1;\n  let longestMatch = 0;\n  let matchStack = {\n    type: STUB,\n    syntax: null,\n    token: null,\n    prev: null\n  };\n  moveToNextToken();\n  while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {\n    // function mapList(list, fn) {\n    //     const result = [];\n    //     while (list) {\n    //         result.unshift(fn(list));\n    //         list = list.prev;\n    //     }\n    //     return result;\n    // }\n    // console.log('--\\n',\n    //     '#' + iterationCount,\n    //     require('util').inspect({\n    //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),\n    //         token: token && token.value,\n    //         tokenIndex,\n    //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')\n    //     }, { depth: null })\n    // );\n    switch (state.type) {\n      case 'Match':\n        if (thenStack === null) {\n          // turn to MISMATCH when some tokens left unmatched\n          if (token !== null) {\n            // doesn't mismatch if just one token left and it's an IE hack\n            if (tokenIndex !== tokens.length - 1 || token.value !== '\\\\0' && token.value !== '\\\\9') {\n              state = matchGraph.MISMATCH;\n              break;\n            }\n          }\n\n          // break the main loop, return a result - MATCH\n          exitReason = EXIT_REASON_MATCH;\n          break;\n        }\n\n        // go to next syntax (`then` branch)\n        state = thenStack.nextState;\n\n        // check match is not empty\n        if (state === matchGraph.DISALLOW_EMPTY) {\n          if (thenStack.matchStack === matchStack) {\n            state = matchGraph.MISMATCH;\n            break;\n          } else {\n            state = matchGraph.MATCH;\n          }\n        }\n\n        // close syntax if needed\n        while (thenStack.syntaxStack !== syntaxStack) {\n          closeSyntax();\n        }\n\n        // pop stack\n        thenStack = thenStack.prev;\n        break;\n      case 'Mismatch':\n        // when some syntax is stashed\n        if (syntaxStash !== null && syntaxStash !== false) {\n          // there is no else branches or a branch reduce match stack\n          if (elseStack === null || tokenIndex > elseStack.tokenIndex) {\n            // restore state from the stash\n            elseStack = syntaxStash;\n            syntaxStash = false; // disable stashing\n          }\n        } else if (elseStack === null) {\n          // no else branches -> break the main loop\n          // return a result - MISMATCH\n          exitReason = EXIT_REASON_MISMATCH;\n          break;\n        }\n\n        // go to next syntax (`else` branch)\n        state = elseStack.nextState;\n\n        // restore all the rest stack states\n        thenStack = elseStack.thenStack;\n        syntaxStack = elseStack.syntaxStack;\n        matchStack = elseStack.matchStack;\n        tokenIndex = elseStack.tokenIndex;\n        token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n\n        // pop stack\n        elseStack = elseStack.prev;\n        break;\n      case 'MatchGraph':\n        state = state.match;\n        break;\n      case 'If':\n        // IMPORTANT: else stack push must go first,\n        // since it stores the state of thenStack before changes\n        if (state.else !== matchGraph.MISMATCH) {\n          pushElseStack(state.else);\n        }\n        if (state.then !== matchGraph.MATCH) {\n          pushThenStack(state.then);\n        }\n        state = state.match;\n        break;\n      case 'MatchOnce':\n        state = {\n          type: 'MatchOnceBuffer',\n          syntax: state,\n          index: 0,\n          mask: 0\n        };\n        break;\n      case 'MatchOnceBuffer':\n        {\n          const terms = state.syntax.terms;\n          if (state.index === terms.length) {\n            // no matches at all or it's required all terms to be matched\n            if (state.mask === 0 || state.syntax.all) {\n              state = matchGraph.MISMATCH;\n              break;\n            }\n\n            // a partial match is ok\n            state = matchGraph.MATCH;\n            break;\n          }\n\n          // all terms are matched\n          if (state.mask === (1 << terms.length) - 1) {\n            state = matchGraph.MATCH;\n            break;\n          }\n          for (; state.index < terms.length; state.index++) {\n            const matchFlag = 1 << state.index;\n            if ((state.mask & matchFlag) === 0) {\n              // IMPORTANT: else stack push must go first,\n              // since it stores the state of thenStack before changes\n              pushElseStack(state);\n              pushThenStack({\n                type: 'AddMatchOnce',\n                syntax: state.syntax,\n                mask: state.mask | matchFlag\n              });\n\n              // match\n              state = terms[state.index++];\n              break;\n            }\n          }\n          break;\n        }\n      case 'AddMatchOnce':\n        state = {\n          type: 'MatchOnceBuffer',\n          syntax: state.syntax,\n          index: 0,\n          mask: state.mask\n        };\n        break;\n      case 'Enum':\n        if (token !== null) {\n          let name = token.value.toLowerCase();\n\n          // drop \\0 and \\9 hack from keyword name\n          if (name.indexOf('\\\\') !== -1) {\n            name = name.replace(/\\\\[09].*$/, '');\n          }\n          if (hasOwnProperty.call(state.map, name)) {\n            state = state.map[name];\n            break;\n          }\n        }\n        state = matchGraph.MISMATCH;\n        break;\n      case 'Generic':\n        {\n          const opts = syntaxStack !== null ? syntaxStack.opts : null;\n          const lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));\n          if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {\n            while (tokenIndex < lastTokenIndex) {\n              addTokenToMatch();\n            }\n            state = matchGraph.MATCH;\n          } else {\n            state = matchGraph.MISMATCH;\n          }\n          break;\n        }\n      case 'Type':\n      case 'Property':\n        {\n          const syntaxDict = state.type === 'Type' ? 'types' : 'properties';\n          const dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;\n          if (!dictSyntax || !dictSyntax.match) {\n            throw new Error('Bad syntax reference: ' + (state.type === 'Type' ? '<' + state.name + '>' : '<\\'' + state.name + '\\'>'));\n          }\n\n          // stash a syntax for types with low priority\n          if (syntaxStash !== false && token !== null && state.type === 'Type') {\n            const lowPriorityMatching =\n            // https://drafts.csswg.org/css-values-4/#custom-idents\n            // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production\n            // can only claim the keyword if no other unfulfilled production can claim it.\n            state.name === 'custom-ident' && token.type === types.Ident ||\n            // https://drafts.csswg.org/css-values-4/#lengths\n            // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),\n            // it must parse as a <number>\n            state.name === 'length' && token.value === '0';\n            if (lowPriorityMatching) {\n              if (syntaxStash === null) {\n                syntaxStash = stateSnapshotFromSyntax(state, elseStack);\n              }\n              state = matchGraph.MISMATCH;\n              break;\n            }\n          }\n          openSyntax();\n          state = dictSyntax.match;\n          break;\n        }\n      case 'Keyword':\n        {\n          const name = state.name;\n          if (token !== null) {\n            let keywordName = token.value;\n\n            // drop \\0 and \\9 hack from keyword name\n            if (keywordName.indexOf('\\\\') !== -1) {\n              keywordName = keywordName.replace(/\\\\[09].*$/, '');\n            }\n            if (areStringsEqualCaseInsensitive(keywordName, name)) {\n              addTokenToMatch();\n              state = matchGraph.MATCH;\n              break;\n            }\n          }\n          state = matchGraph.MISMATCH;\n          break;\n        }\n      case 'AtKeyword':\n      case 'Function':\n        if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {\n          addTokenToMatch();\n          state = matchGraph.MATCH;\n          break;\n        }\n        state = matchGraph.MISMATCH;\n        break;\n      case 'Token':\n        if (token !== null && token.value === state.value) {\n          addTokenToMatch();\n          state = matchGraph.MATCH;\n          break;\n        }\n        state = matchGraph.MISMATCH;\n        break;\n      case 'Comma':\n        if (token !== null && token.type === types.Comma) {\n          if (isCommaContextStart(matchStack.token)) {\n            state = matchGraph.MISMATCH;\n          } else {\n            addTokenToMatch();\n            state = isCommaContextEnd(token) ? matchGraph.MISMATCH : matchGraph.MATCH;\n          }\n        } else {\n          state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? matchGraph.MATCH : matchGraph.MISMATCH;\n        }\n        break;\n      case 'String':\n        let string = '';\n        let lastTokenIndex = tokenIndex;\n        for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {\n          string += tokens[lastTokenIndex].value;\n        }\n        if (areStringsEqualCaseInsensitive(string, state.value)) {\n          while (tokenIndex < lastTokenIndex) {\n            addTokenToMatch();\n          }\n          state = matchGraph.MATCH;\n        } else {\n          state = matchGraph.MISMATCH;\n        }\n        break;\n      default:\n        throw new Error('Unknown node type: ' + state.type);\n    }\n  }\n  switch (exitReason) {\n    case null:\n      console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');\n      exitReason = EXIT_REASON_ITERATION_LIMIT;\n      matchStack = null;\n      break;\n    case EXIT_REASON_MATCH:\n      while (syntaxStack !== null) {\n        closeSyntax();\n      }\n      break;\n    default:\n      matchStack = null;\n  }\n  return {\n    tokens,\n    reason: exitReason,\n    iterations: iterationCount,\n    match: matchStack,\n    longestMatch\n  };\n}\nfunction matchAsList(tokens, matchGraph, syntaxes) {\n  const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n  if (matchResult.match !== null) {\n    let item = reverseList(matchResult.match).prev;\n    matchResult.match = [];\n    while (item !== null) {\n      switch (item.type) {\n        case OPEN_SYNTAX:\n        case CLOSE_SYNTAX:\n          matchResult.match.push({\n            type: item.type,\n            syntax: item.syntax\n          });\n          break;\n        default:\n          matchResult.match.push({\n            token: item.token.value,\n            node: item.token.node\n          });\n          break;\n      }\n      item = item.prev;\n    }\n  }\n  return matchResult;\n}\nfunction matchAsTree(tokens, matchGraph, syntaxes) {\n  const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n  if (matchResult.match === null) {\n    return matchResult;\n  }\n  let item = matchResult.match;\n  let host = matchResult.match = {\n    syntax: matchGraph.syntax || null,\n    match: []\n  };\n  const hostStack = [host];\n\n  // revert a list and start with 2nd item since 1st is a stub item\n  item = reverseList(item).prev;\n\n  // build a tree\n  while (item !== null) {\n    switch (item.type) {\n      case OPEN_SYNTAX:\n        host.match.push(host = {\n          syntax: item.syntax,\n          match: []\n        });\n        hostStack.push(host);\n        break;\n      case CLOSE_SYNTAX:\n        hostStack.pop();\n        host = hostStack[hostStack.length - 1];\n        break;\n      default:\n        host.match.push({\n          syntax: item.syntax || null,\n          token: item.token.value,\n          node: item.token.node\n        });\n    }\n    item = item.prev;\n  }\n  return matchResult;\n}\nexports.matchAsList = matchAsList;\nexports.matchAsTree = matchAsTree;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}