{"ast":null,"code":"'use strict';\n\nconst {\n  collectStylesheet\n} = require('../lib/style');\nconst {\n  detachNodeFromParent,\n  querySelectorAll\n} = require('../lib/xast');\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n * @typedef {import('../lib/types').XastParent} XastParent\n * @typedef {import('../lib/types').XastNode} XastNode\n */\n\nexports.name = 'reusePaths';\nexports.description = 'Finds <path> elements with the same d, fill, and ' + 'stroke, and converts them to <use> elements ' + 'referencing a single <path> def.';\n\n/**\n * Finds <path> elements with the same d, fill, and stroke, and converts them to\n * <use> elements referencing a single <path> def.\n *\n * @author Jacob Howcroft\n *\n * @type {import('./plugins-types').Plugin<'reusePaths'>}\n */\nexports.fn = root => {\n  const stylesheet = collectStylesheet(root);\n\n  /**\n   * @type {Map<string, XastElement[]>}\n   */\n  const paths = new Map();\n\n  /**\n   * Reference to the first defs element that is a direct child of the svg\n   * element if one exists.\n   *\n   * @type {XastElement}\n   * @see https://developer.mozilla.org/docs/Web/SVG/Element/defs\n   */\n  let svgDefs;\n\n  /**\n   * Set of hrefs that reference the id of another node.\n   *\n   * @type {Set<string>}\n   */\n  const hrefs = new Set();\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        if (node.name === 'path' && node.attributes.d != null) {\n          const d = node.attributes.d;\n          const fill = node.attributes.fill || '';\n          const stroke = node.attributes.stroke || '';\n          const key = d + ';s:' + stroke + ';f:' + fill;\n          let list = paths.get(key);\n          if (list == null) {\n            list = [];\n            paths.set(key, list);\n          }\n          list.push(node);\n        }\n        if (svgDefs == null && node.name === 'defs' && parentNode.type === 'element' && parentNode.name === 'svg') {\n          svgDefs = node;\n        }\n        if (node.name === 'use') {\n          for (const name of ['href', 'xlink:href']) {\n            const href = node.attributes[name];\n            if (href != null && href.startsWith('#') && href.length > 1) {\n              hrefs.add(href.slice(1));\n            }\n          }\n        }\n      },\n      exit: (node, parentNode) => {\n        if (node.name === 'svg' && parentNode.type === 'root') {\n          let defsTag = svgDefs;\n          if (defsTag == null) {\n            defsTag = {\n              type: 'element',\n              name: 'defs',\n              attributes: {},\n              children: []\n            };\n            // TODO remove legacy parentNode in v4\n            Object.defineProperty(defsTag, 'parentNode', {\n              writable: true,\n              value: node\n            });\n          }\n          let index = 0;\n          for (const list of paths.values()) {\n            if (list.length > 1) {\n              /** @type {XastElement} */\n              const reusablePath = {\n                type: 'element',\n                name: 'path',\n                attributes: {},\n                children: []\n              };\n              for (const attr of ['fill', 'stroke', 'd']) {\n                if (list[0].attributes[attr] != null) {\n                  reusablePath.attributes[attr] = list[0].attributes[attr];\n                }\n              }\n              const originalId = list[0].attributes.id;\n              if (originalId == null || hrefs.has(originalId) || stylesheet.rules.some(rule => rule.selector === `#${originalId}`)) {\n                reusablePath.attributes.id = 'reuse-' + index++;\n              } else {\n                reusablePath.attributes.id = originalId;\n                delete list[0].attributes.id;\n              }\n              // TODO remove legacy parentNode in v4\n              Object.defineProperty(reusablePath, 'parentNode', {\n                writable: true,\n                value: defsTag\n              });\n              defsTag.children.push(reusablePath);\n              // convert paths to <use>\n              for (const pathNode of list) {\n                delete pathNode.attributes.d;\n                delete pathNode.attributes.stroke;\n                delete pathNode.attributes.fill;\n                if (defsTag.children.includes(pathNode) && pathNode.children.length === 0) {\n                  if (Object.keys(pathNode.attributes).length === 0) {\n                    detachNodeFromParent(pathNode, defsTag);\n                    continue;\n                  }\n                  if (Object.keys(pathNode.attributes).length === 1 && pathNode.attributes.id != null) {\n                    detachNodeFromParent(pathNode, defsTag);\n                    const selector = `[xlink\\\\:href=#${pathNode.attributes.id}], [href=#${pathNode.attributes.id}]`;\n                    for (const child of querySelectorAll(node, selector)) {\n                      if (child.type !== 'element') {\n                        continue;\n                      }\n                      for (const name of ['href', 'xlink:href']) {\n                        if (child.attributes[name] != null) {\n                          child.attributes[name] = '#' + reusablePath.attributes.id;\n                        }\n                      }\n                    }\n                    continue;\n                  }\n                }\n                pathNode.name = 'use';\n                pathNode.attributes['xlink:href'] = '#' + reusablePath.attributes.id;\n              }\n            }\n          }\n          if (defsTag.children.length !== 0) {\n            if (node.attributes['xmlns:xlink'] == null) {\n              node.attributes['xmlns:xlink'] = 'http://www.w3.org/1999/xlink';\n            }\n            if (svgDefs == null) {\n              node.children.unshift(defsTag);\n            }\n          }\n        }\n      }\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}