{"ast":null,"code":"'use strict';\n\nconst cssTree = require('css-tree');\nconst REPLACE = 1;\nconst REMOVE = 2;\nconst TOP = 0;\nconst RIGHT = 1;\nconst BOTTOM = 2;\nconst LEFT = 3;\nconst SIDES = ['top', 'right', 'bottom', 'left'];\nconst SIDE = {\n  'margin-top': 'top',\n  'margin-right': 'right',\n  'margin-bottom': 'bottom',\n  'margin-left': 'left',\n  'padding-top': 'top',\n  'padding-right': 'right',\n  'padding-bottom': 'bottom',\n  'padding-left': 'left',\n  'border-top-color': 'top',\n  'border-right-color': 'right',\n  'border-bottom-color': 'bottom',\n  'border-left-color': 'left',\n  'border-top-width': 'top',\n  'border-right-width': 'right',\n  'border-bottom-width': 'bottom',\n  'border-left-width': 'left',\n  'border-top-style': 'top',\n  'border-right-style': 'right',\n  'border-bottom-style': 'bottom',\n  'border-left-style': 'left'\n};\nconst MAIN_PROPERTY = {\n  'margin': 'margin',\n  'margin-top': 'margin',\n  'margin-right': 'margin',\n  'margin-bottom': 'margin',\n  'margin-left': 'margin',\n  'padding': 'padding',\n  'padding-top': 'padding',\n  'padding-right': 'padding',\n  'padding-bottom': 'padding',\n  'padding-left': 'padding',\n  'border-color': 'border-color',\n  'border-top-color': 'border-color',\n  'border-right-color': 'border-color',\n  'border-bottom-color': 'border-color',\n  'border-left-color': 'border-color',\n  'border-width': 'border-width',\n  'border-top-width': 'border-width',\n  'border-right-width': 'border-width',\n  'border-bottom-width': 'border-width',\n  'border-left-width': 'border-width',\n  'border-style': 'border-style',\n  'border-top-style': 'border-style',\n  'border-right-style': 'border-style',\n  'border-bottom-style': 'border-style',\n  'border-left-style': 'border-style'\n};\nclass TRBL {\n  constructor(name) {\n    this.name = name;\n    this.loc = null;\n    this.iehack = undefined;\n    this.sides = {\n      'top': null,\n      'right': null,\n      'bottom': null,\n      'left': null\n    };\n  }\n  getValueSequence(declaration, count) {\n    const values = [];\n    let iehack = '';\n    const hasBadValues = declaration.value.type !== 'Value' || declaration.value.children.some(function (child) {\n      let special = false;\n      switch (child.type) {\n        case 'Identifier':\n          switch (child.name) {\n            case '\\\\0':\n            case '\\\\9':\n              iehack = child.name;\n              return;\n            case 'inherit':\n            case 'initial':\n            case 'unset':\n            case 'revert':\n              special = child.name;\n              break;\n          }\n          break;\n        case 'Dimension':\n          switch (child.unit) {\n            // is not supported until IE11\n            case 'rem':\n\n            // v* units is too buggy across browsers and better\n            // don't merge values with those units\n            case 'vw':\n            case 'vh':\n            case 'vmin':\n            case 'vmax':\n            case 'vm':\n              // IE9 supporting \"vm\" instead of \"vmin\".\n              special = child.unit;\n              break;\n          }\n          break;\n        case 'Hash': // color\n        case 'Number':\n        case 'Percentage':\n          break;\n        case 'Function':\n          if (child.name === 'var') {\n            return true;\n          }\n          special = child.name;\n          break;\n        default:\n          return true;\n        // bad value\n      }\n      values.push({\n        node: child,\n        special,\n        important: declaration.important\n      });\n    });\n    if (hasBadValues || values.length > count) {\n      return false;\n    }\n    if (typeof this.iehack === 'string' && this.iehack !== iehack) {\n      return false;\n    }\n    this.iehack = iehack; // move outside\n\n    return values;\n  }\n  canOverride(side, value) {\n    const currentValue = this.sides[side];\n    return !currentValue || value.important && !currentValue.important;\n  }\n  add(name, declaration) {\n    function attemptToAdd() {\n      const sides = this.sides;\n      const side = SIDE[name];\n      if (side) {\n        if (side in sides === false) {\n          return false;\n        }\n        const values = this.getValueSequence(declaration, 1);\n        if (!values || !values.length) {\n          return false;\n        }\n\n        // can mix only if specials are equal\n        for (const key in sides) {\n          if (sides[key] !== null && sides[key].special !== values[0].special) {\n            return false;\n          }\n        }\n        if (!this.canOverride(side, values[0])) {\n          return true;\n        }\n        sides[side] = values[0];\n        return true;\n      } else if (name === this.name) {\n        const values = this.getValueSequence(declaration, 4);\n        if (!values || !values.length) {\n          return false;\n        }\n        switch (values.length) {\n          case 1:\n            values[RIGHT] = values[TOP];\n            values[BOTTOM] = values[TOP];\n            values[LEFT] = values[TOP];\n            break;\n          case 2:\n            values[BOTTOM] = values[TOP];\n            values[LEFT] = values[RIGHT];\n            break;\n          case 3:\n            values[LEFT] = values[RIGHT];\n            break;\n        }\n\n        // can mix only if specials are equal\n        for (let i = 0; i < 4; i++) {\n          for (const key in sides) {\n            if (sides[key] !== null && sides[key].special !== values[i].special) {\n              return false;\n            }\n          }\n        }\n        for (let i = 0; i < 4; i++) {\n          if (this.canOverride(SIDES[i], values[i])) {\n            sides[SIDES[i]] = values[i];\n          }\n        }\n        return true;\n      }\n    }\n    if (!attemptToAdd.call(this)) {\n      return false;\n    }\n\n    // TODO: use it when we can refer to several points in source\n    // if (this.loc) {\n    //     this.loc = {\n    //         primary: this.loc,\n    //         merged: declaration.loc\n    //     };\n    // } else {\n    //     this.loc = declaration.loc;\n    // }\n    if (!this.loc) {\n      this.loc = declaration.loc;\n    }\n    return true;\n  }\n  isOkToMinimize() {\n    const top = this.sides.top;\n    const right = this.sides.right;\n    const bottom = this.sides.bottom;\n    const left = this.sides.left;\n    if (top && right && bottom && left) {\n      const important = top.important + right.important + bottom.important + left.important;\n      return important === 0 || important === 4;\n    }\n    return false;\n  }\n  getValue() {\n    const result = new cssTree.List();\n    const sides = this.sides;\n    const values = [sides.top, sides.right, sides.bottom, sides.left];\n    const stringValues = [cssTree.generate(sides.top.node), cssTree.generate(sides.right.node), cssTree.generate(sides.bottom.node), cssTree.generate(sides.left.node)];\n    if (stringValues[LEFT] === stringValues[RIGHT]) {\n      values.pop();\n      if (stringValues[BOTTOM] === stringValues[TOP]) {\n        values.pop();\n        if (stringValues[RIGHT] === stringValues[TOP]) {\n          values.pop();\n        }\n      }\n    }\n    for (let i = 0; i < values.length; i++) {\n      result.appendData(values[i].node);\n    }\n    if (this.iehack) {\n      result.appendData({\n        type: 'Identifier',\n        loc: null,\n        name: this.iehack\n      });\n    }\n    return {\n      type: 'Value',\n      loc: null,\n      children: result\n    };\n  }\n  getDeclaration() {\n    return {\n      type: 'Declaration',\n      loc: this.loc,\n      important: this.sides.top.important,\n      property: this.name,\n      value: this.getValue()\n    };\n  }\n}\nfunction processRule(rule, shorts, shortDeclarations, lastShortSelector) {\n  const declarations = rule.block.children;\n  const selector = rule.prelude.children.first.id;\n  rule.block.children.forEachRight(function (declaration, item) {\n    const property = declaration.property;\n    if (!MAIN_PROPERTY.hasOwnProperty(property)) {\n      return;\n    }\n    const key = MAIN_PROPERTY[property];\n    let shorthand;\n    let operation;\n    if (!lastShortSelector || selector === lastShortSelector) {\n      if (key in shorts) {\n        operation = REMOVE;\n        shorthand = shorts[key];\n      }\n    }\n    if (!shorthand || !shorthand.add(property, declaration)) {\n      operation = REPLACE;\n      shorthand = new TRBL(key);\n\n      // if can't parse value ignore it and break shorthand children\n      if (!shorthand.add(property, declaration)) {\n        lastShortSelector = null;\n        return;\n      }\n    }\n    shorts[key] = shorthand;\n    shortDeclarations.push({\n      operation,\n      block: declarations,\n      item,\n      shorthand\n    });\n    lastShortSelector = selector;\n  });\n  return lastShortSelector;\n}\nfunction processShorthands(shortDeclarations, markDeclaration) {\n  shortDeclarations.forEach(function (item) {\n    const shorthand = item.shorthand;\n    if (!shorthand.isOkToMinimize()) {\n      return;\n    }\n    if (item.operation === REPLACE) {\n      item.item.data = markDeclaration(shorthand.getDeclaration());\n    } else {\n      item.block.remove(item.item);\n    }\n  });\n}\nfunction restructBlock(ast, indexer) {\n  const stylesheetMap = {};\n  const shortDeclarations = [];\n  cssTree.walk(ast, {\n    visit: 'Rule',\n    reverse: true,\n    enter(node) {\n      const stylesheet = this.block || this.stylesheet;\n      const ruleId = (node.pseudoSignature || '') + '|' + node.prelude.children.first.id;\n      let ruleMap;\n      let shorts;\n      if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {\n        ruleMap = {\n          lastShortSelector: null\n        };\n        stylesheetMap[stylesheet.id] = ruleMap;\n      } else {\n        ruleMap = stylesheetMap[stylesheet.id];\n      }\n      if (ruleMap.hasOwnProperty(ruleId)) {\n        shorts = ruleMap[ruleId];\n      } else {\n        shorts = {};\n        ruleMap[ruleId] = shorts;\n      }\n      ruleMap.lastShortSelector = processRule.call(this, node, shorts, shortDeclarations, ruleMap.lastShortSelector);\n    }\n  });\n  processShorthands(shortDeclarations, indexer.declaration);\n}\nmodule.exports = restructBlock;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}