{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('css-tree').Rule} CsstreeRule\n * @typedef {import('./types').Specificity} Specificity\n * @typedef {import('./types').Stylesheet} Stylesheet\n * @typedef {import('./types').StylesheetRule} StylesheetRule\n * @typedef {import('./types').StylesheetDeclaration} StylesheetDeclaration\n * @typedef {import('./types').ComputedStyles} ComputedStyles\n * @typedef {import('./types').XastRoot} XastRoot\n * @typedef {import('./types').XastElement} XastElement\n * @typedef {import('./types').XastParent} XastParent\n * @typedef {import('./types').XastChild} XastChild\n */\nconst csstree = require('css-tree');\nconst csswhat = require('css-what');\nconst {\n  syntax: {\n    specificity\n  }\n} = require('csso');\nconst {\n  visit,\n  matches\n} = require('./xast.js');\nconst {\n  attrsGroups,\n  inheritableAttrs,\n  presentationNonInheritableGroupAttrs\n} = require('../plugins/_collections.js');\n\n// @ts-ignore not defined in @types/csstree\nconst csstreeWalkSkip = csstree.walk.skip;\n\n/**\n * @type {(ruleNode: CsstreeRule, dynamic: boolean) => StylesheetRule[]}\n */\nconst parseRule = (ruleNode, dynamic) => {\n  /**\n   * @type {StylesheetDeclaration[]}\n   */\n  const declarations = [];\n  // collect declarations\n  ruleNode.block.children.forEach(cssNode => {\n    if (cssNode.type === 'Declaration') {\n      declarations.push({\n        name: cssNode.property,\n        value: csstree.generate(cssNode.value),\n        important: cssNode.important === true\n      });\n    }\n  });\n\n  /** @type {StylesheetRule[]} */\n  const rules = [];\n  csstree.walk(ruleNode.prelude, node => {\n    if (node.type === 'Selector') {\n      const newNode = csstree.clone(node);\n      let hasPseudoClasses = false;\n      csstree.walk(newNode, (pseudoClassNode, item, list) => {\n        if (pseudoClassNode.type === 'PseudoClassSelector') {\n          hasPseudoClasses = true;\n          list.remove(item);\n        }\n      });\n      rules.push({\n        specificity: specificity(node),\n        dynamic: hasPseudoClasses || dynamic,\n        // compute specificity from original node to consider pseudo classes\n        selector: csstree.generate(newNode),\n        declarations\n      });\n    }\n  });\n  return rules;\n};\n\n/**\n * @type {(css: string, dynamic: boolean) => StylesheetRule[]}\n */\nconst parseStylesheet = (css, dynamic) => {\n  /** @type {StylesheetRule[]} */\n  const rules = [];\n  const ast = csstree.parse(css, {\n    parseValue: false,\n    parseAtrulePrelude: false\n  });\n  csstree.walk(ast, cssNode => {\n    if (cssNode.type === 'Rule') {\n      rules.push(...parseRule(cssNode, dynamic || false));\n      return csstreeWalkSkip;\n    }\n    if (cssNode.type === 'Atrule') {\n      if (cssNode.name === 'keyframes' || cssNode.name === '-webkit-keyframes') {\n        return csstreeWalkSkip;\n      }\n      csstree.walk(cssNode, ruleNode => {\n        if (ruleNode.type === 'Rule') {\n          rules.push(...parseRule(ruleNode, dynamic || true));\n          return csstreeWalkSkip;\n        }\n      });\n      return csstreeWalkSkip;\n    }\n  });\n  return rules;\n};\n\n/**\n * @type {(css: string) => StylesheetDeclaration[]}\n */\nconst parseStyleDeclarations = css => {\n  /** @type {StylesheetDeclaration[]} */\n  const declarations = [];\n  const ast = csstree.parse(css, {\n    context: 'declarationList',\n    parseValue: false\n  });\n  csstree.walk(ast, cssNode => {\n    if (cssNode.type === 'Declaration') {\n      declarations.push({\n        name: cssNode.property,\n        value: csstree.generate(cssNode.value),\n        important: cssNode.important === true\n      });\n    }\n  });\n  return declarations;\n};\n\n/**\n * @param {Stylesheet} stylesheet\n * @param {XastElement} node\n * @returns {ComputedStyles}\n */\nconst computeOwnStyle = (stylesheet, node) => {\n  /** @type {ComputedStyles} */\n  const computedStyle = {};\n  const importantStyles = new Map();\n\n  // collect attributes\n  for (const [name, value] of Object.entries(node.attributes)) {\n    if (attrsGroups.presentation.has(name)) {\n      computedStyle[name] = {\n        type: 'static',\n        inherited: false,\n        value\n      };\n      importantStyles.set(name, false);\n    }\n  }\n\n  // collect matching rules\n  for (const {\n    selector,\n    declarations,\n    dynamic\n  } of stylesheet.rules) {\n    if (matches(node, selector)) {\n      for (const {\n        name,\n        value,\n        important\n      } of declarations) {\n        const computed = computedStyle[name];\n        if (computed && computed.type === 'dynamic') {\n          continue;\n        }\n        if (dynamic) {\n          computedStyle[name] = {\n            type: 'dynamic',\n            inherited: false\n          };\n          continue;\n        }\n        if (computed == null || important === true || importantStyles.get(name) === false) {\n          computedStyle[name] = {\n            type: 'static',\n            inherited: false,\n            value\n          };\n          importantStyles.set(name, important);\n        }\n      }\n    }\n  }\n\n  // collect inline styles\n  const styleDeclarations = node.attributes.style == null ? [] : parseStyleDeclarations(node.attributes.style);\n  for (const {\n    name,\n    value,\n    important\n  } of styleDeclarations) {\n    const computed = computedStyle[name];\n    if (computed && computed.type === 'dynamic') {\n      continue;\n    }\n    if (computed == null || important === true || importantStyles.get(name) === false) {\n      computedStyle[name] = {\n        type: 'static',\n        inherited: false,\n        value\n      };\n      importantStyles.set(name, important);\n    }\n  }\n  return computedStyle;\n};\n\n/**\n * Compares selector specificities.\n * Derived from https://github.com/keeganstreet/specificity/blob/8757133ddd2ed0163f120900047ff0f92760b536/specificity.js#L207\n *\n * @param {Specificity} a\n * @param {Specificity} b\n * @returns {number}\n */\nconst compareSpecificity = (a, b) => {\n  for (let i = 0; i < 4; i += 1) {\n    if (a[i] < b[i]) {\n      return -1;\n    } else if (a[i] > b[i]) {\n      return 1;\n    }\n  }\n  return 0;\n};\nexports.compareSpecificity = compareSpecificity;\n\n/**\n * @type {(root: XastRoot) => Stylesheet}\n */\nconst collectStylesheet = root => {\n  /** @type {StylesheetRule[]} */\n  const rules = [];\n  /** @type {Map<XastElement, XastParent>} */\n  const parents = new Map();\n  visit(root, {\n    element: {\n      enter: (node, parentNode) => {\n        parents.set(node, parentNode);\n        if (node.name !== 'style') {\n          return;\n        }\n        if (node.attributes.type == null || node.attributes.type === '' || node.attributes.type === 'text/css') {\n          const dynamic = node.attributes.media != null && node.attributes.media !== 'all';\n          for (const child of node.children) {\n            if (child.type === 'text' || child.type === 'cdata') {\n              rules.push(...parseStylesheet(child.value, dynamic));\n            }\n          }\n        }\n      }\n    }\n  });\n  // sort by selectors specificity\n  rules.sort((a, b) => compareSpecificity(a.specificity, b.specificity));\n  return {\n    rules,\n    parents\n  };\n};\nexports.collectStylesheet = collectStylesheet;\n\n/**\n * @param {Stylesheet} stylesheet\n * @param {XastElement} node\n * @returns {ComputedStyles}\n */\nconst computeStyle = (stylesheet, node) => {\n  const {\n    parents\n  } = stylesheet;\n  const computedStyles = computeOwnStyle(stylesheet, node);\n  let parent = parents.get(node);\n  while (parent != null && parent.type !== 'root') {\n    const inheritedStyles = computeOwnStyle(stylesheet, parent);\n    for (const [name, computed] of Object.entries(inheritedStyles)) {\n      if (computedStyles[name] == null && inheritableAttrs.has(name) && !presentationNonInheritableGroupAttrs.has(name)) {\n        computedStyles[name] = {\n          ...computed,\n          inherited: true\n        };\n      }\n    }\n    parent = parents.get(parent);\n  }\n  return computedStyles;\n};\nexports.computeStyle = computeStyle;\n\n/**\n * Determines if the CSS selector includes or traverses the given attribute.\n *\n * Classes and IDs are generated as attribute selectors, so you can check for\n * if a `.class` or `#id` is included by passing `name=class` or `name=id`\n * respectively.\n *\n * @param {csstree.ListItem<csstree.CssNode>|string} selector\n * @param {string} name\n * @param {?string} value\n * @param {boolean} traversed\n * @returns {boolean}\n */\nconst includesAttrSelector = (selector, name, value = null, traversed = false) => {\n  const selectors = typeof selector === 'string' ? csswhat.parse(selector) : csswhat.parse(csstree.generate(selector.data));\n  for (const subselector of selectors) {\n    const hasAttrSelector = subselector.some((segment, index) => {\n      if (traversed) {\n        if (index === subselector.length - 1) {\n          return false;\n        }\n        const isNextTraversal = csswhat.isTraversal(subselector[index + 1]);\n        if (!isNextTraversal) {\n          return false;\n        }\n      }\n      if (segment.type !== 'attribute' || segment.name !== name) {\n        return false;\n      }\n      return value == null ? true : segment.value === value;\n    });\n    if (hasAttrSelector) {\n      return true;\n    }\n  }\n  return false;\n};\nexports.includesAttrSelector = includesAttrSelector;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}