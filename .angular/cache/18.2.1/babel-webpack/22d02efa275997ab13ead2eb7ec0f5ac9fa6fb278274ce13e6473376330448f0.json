{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types').PathDataItem} PathDataItem\n */\nconst {\n  stringifyPathData\n} = require('../lib/path.js');\nconst {\n  detachNodeFromParent\n} = require('../lib/xast.js');\nexports.name = 'convertShapeToPath';\nexports.description = 'converts basic shapes to more compact path form';\nconst regNumber = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/g;\n\n/**\n * Converts basic shape to more compact path.\n * It also allows further optimizations like\n * combining paths with similar attributes.\n *\n * @see https://www.w3.org/TR/SVG11/shapes.html\n *\n * @author Lev Solntsev\n *\n * @type {import('./plugins-types').Plugin<'convertShapeToPath'>}\n */\nexports.fn = (root, params) => {\n  const {\n    convertArcs = false,\n    floatPrecision: precision\n  } = params;\n  return {\n    element: {\n      enter: (node, parentNode) => {\n        // convert rect to path\n        if (node.name === 'rect' && node.attributes.width != null && node.attributes.height != null && node.attributes.rx == null && node.attributes.ry == null) {\n          const x = Number(node.attributes.x || '0');\n          const y = Number(node.attributes.y || '0');\n          const width = Number(node.attributes.width);\n          const height = Number(node.attributes.height);\n          // Values like '100%' compute to NaN, thus running after\n          // cleanupNumericValues when 'px' units has already been removed.\n          // TODO: Calculate sizes from % and non-px units if possible.\n          if (Number.isNaN(x - y + width - height)) return;\n          /**\n           * @type {PathDataItem[]}\n           */\n          const pathData = [{\n            command: 'M',\n            args: [x, y]\n          }, {\n            command: 'H',\n            args: [x + width]\n          }, {\n            command: 'V',\n            args: [y + height]\n          }, {\n            command: 'H',\n            args: [x]\n          }, {\n            command: 'z',\n            args: []\n          }];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.x;\n          delete node.attributes.y;\n          delete node.attributes.width;\n          delete node.attributes.height;\n        }\n\n        // convert line to path\n        if (node.name === 'line') {\n          const x1 = Number(node.attributes.x1 || '0');\n          const y1 = Number(node.attributes.y1 || '0');\n          const x2 = Number(node.attributes.x2 || '0');\n          const y2 = Number(node.attributes.y2 || '0');\n          if (Number.isNaN(x1 - y1 + x2 - y2)) return;\n          /**\n           * @type {PathDataItem[]}\n           */\n          const pathData = [{\n            command: 'M',\n            args: [x1, y1]\n          }, {\n            command: 'L',\n            args: [x2, y2]\n          }];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.x1;\n          delete node.attributes.y1;\n          delete node.attributes.x2;\n          delete node.attributes.y2;\n        }\n\n        // convert polyline and polygon to path\n        if ((node.name === 'polyline' || node.name === 'polygon') && node.attributes.points != null) {\n          const coords = (node.attributes.points.match(regNumber) || []).map(Number);\n          if (coords.length < 4) {\n            detachNodeFromParent(node, parentNode);\n            return;\n          }\n          /**\n           * @type {PathDataItem[]}\n           */\n          const pathData = [];\n          for (let i = 0; i < coords.length; i += 2) {\n            pathData.push({\n              command: i === 0 ? 'M' : 'L',\n              args: coords.slice(i, i + 2)\n            });\n          }\n          if (node.name === 'polygon') {\n            pathData.push({\n              command: 'z',\n              args: []\n            });\n          }\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.points;\n        }\n\n        //  optionally convert circle\n        if (node.name === 'circle' && convertArcs) {\n          const cx = Number(node.attributes.cx || '0');\n          const cy = Number(node.attributes.cy || '0');\n          const r = Number(node.attributes.r || '0');\n          if (Number.isNaN(cx - cy + r)) {\n            return;\n          }\n          /**\n           * @type {PathDataItem[]}\n           */\n          const pathData = [{\n            command: 'M',\n            args: [cx, cy - r]\n          }, {\n            command: 'A',\n            args: [r, r, 0, 1, 0, cx, cy + r]\n          }, {\n            command: 'A',\n            args: [r, r, 0, 1, 0, cx, cy - r]\n          }, {\n            command: 'z',\n            args: []\n          }];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.cx;\n          delete node.attributes.cy;\n          delete node.attributes.r;\n        }\n\n        // optionally convert ellipse\n        if (node.name === 'ellipse' && convertArcs) {\n          const ecx = Number(node.attributes.cx || '0');\n          const ecy = Number(node.attributes.cy || '0');\n          const rx = Number(node.attributes.rx || '0');\n          const ry = Number(node.attributes.ry || '0');\n          if (Number.isNaN(ecx - ecy + rx - ry)) {\n            return;\n          }\n          /**\n           * @type {PathDataItem[]}\n           */\n          const pathData = [{\n            command: 'M',\n            args: [ecx, ecy - ry]\n          }, {\n            command: 'A',\n            args: [rx, ry, 0, 1, 0, ecx, ecy + ry]\n          }, {\n            command: 'A',\n            args: [rx, ry, 0, 1, 0, ecx, ecy - ry]\n          }, {\n            command: 'z',\n            args: []\n          }];\n          node.name = 'path';\n          node.attributes.d = stringifyPathData({\n            pathData,\n            precision\n          });\n          delete node.attributes.cx;\n          delete node.attributes.cy;\n          delete node.attributes.rx;\n          delete node.attributes.ry;\n        }\n      }\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}