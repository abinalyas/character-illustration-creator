{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types').XastNode} XastNode\n */\nconst {\n  inheritableAttrs,\n  elemsGroups\n} = require('./_collections.js');\nexports.name = 'collapseGroups';\nexports.description = 'collapses useless groups';\n\n/**\n * @type {(node: XastNode, name: string) => boolean}\n */\nconst hasAnimatedAttr = (node, name) => {\n  if (node.type === 'element') {\n    if (elemsGroups.animation.has(node.name) && node.attributes.attributeName === name) {\n      return true;\n    }\n    for (const child of node.children) {\n      if (hasAnimatedAttr(child, name)) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Collapse useless groups.\n *\n * @example\n * <g>\n *     <g attr1=\"val1\">\n *         <path d=\"...\"/>\n *     </g>\n * </g>\n *         ⬇\n * <g>\n *     <g>\n *         <path attr1=\"val1\" d=\"...\"/>\n *     </g>\n * </g>\n *         ⬇\n * <path attr1=\"val1\" d=\"...\"/>\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'collapseGroups'>}\n */\nexports.fn = () => {\n  return {\n    element: {\n      exit: (node, parentNode) => {\n        if (parentNode.type === 'root' || parentNode.name === 'switch') {\n          return;\n        }\n        // non-empty groups\n        if (node.name !== 'g' || node.children.length === 0) {\n          return;\n        }\n\n        // move group attributes to the single child element\n        if (Object.keys(node.attributes).length !== 0 && node.children.length === 1) {\n          const firstChild = node.children[0];\n          // TODO untangle this mess\n          if (firstChild.type === 'element' && firstChild.attributes.id == null && node.attributes.filter == null && (node.attributes.class == null || firstChild.attributes.class == null) && (node.attributes['clip-path'] == null && node.attributes.mask == null || firstChild.name === 'g' && node.attributes.transform == null && firstChild.attributes.transform == null)) {\n            for (const [name, value] of Object.entries(node.attributes)) {\n              // avoid copying to not conflict with animated attribute\n              if (hasAnimatedAttr(firstChild, name)) {\n                return;\n              }\n              if (firstChild.attributes[name] == null) {\n                firstChild.attributes[name] = value;\n              } else if (name === 'transform') {\n                firstChild.attributes[name] = value + ' ' + firstChild.attributes[name];\n              } else if (firstChild.attributes[name] === 'inherit') {\n                firstChild.attributes[name] = value;\n              } else if (inheritableAttrs.has(name) === false && firstChild.attributes[name] !== value) {\n                return;\n              }\n              delete node.attributes[name];\n            }\n          }\n        }\n\n        // collapse groups without attributes\n        if (Object.keys(node.attributes).length === 0) {\n          // animation elements \"add\" attributes to group\n          // group should be preserved\n          for (const child of node.children) {\n            if (child.type === 'element' && elemsGroups.animation.has(child.name)) {\n              return;\n            }\n          }\n          // replace current node with all its children\n          const index = parentNode.children.indexOf(node);\n          parentNode.children.splice(index, 1, ...node.children);\n          // TODO remove legacy parentNode in v4\n          for (const child of node.children) {\n            Object.defineProperty(child, 'parentNode', {\n              writable: true,\n              value: parentNode\n            });\n          }\n        }\n      }\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}