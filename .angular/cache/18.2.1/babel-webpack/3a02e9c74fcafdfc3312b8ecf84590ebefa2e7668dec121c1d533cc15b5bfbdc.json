{"ast":null,"code":"'use strict';\n\nconst adoptBuffer = require('./adopt-buffer.cjs');\nconst utils = require('./utils.cjs');\nconst names = require('./names.cjs');\nconst types = require('./types.cjs');\nconst OFFSET_MASK = 0x00FFFFFF;\nconst TYPE_SHIFT = 24;\nconst balancePair = new Map([[types.Function, types.RightParenthesis], [types.LeftParenthesis, types.RightParenthesis], [types.LeftSquareBracket, types.RightSquareBracket], [types.LeftCurlyBracket, types.RightCurlyBracket]]);\nclass TokenStream {\n  constructor(source, tokenize) {\n    this.setSource(source, tokenize);\n  }\n  reset() {\n    this.eof = false;\n    this.tokenIndex = -1;\n    this.tokenType = 0;\n    this.tokenStart = this.firstCharOffset;\n    this.tokenEnd = this.firstCharOffset;\n  }\n  setSource(source = '', tokenize = () => {}) {\n    source = String(source || '');\n    const sourceLength = source.length;\n    const offsetAndType = adoptBuffer.adoptBuffer(this.offsetAndType, source.length + 1); // +1 because of eof-token\n    const balance = adoptBuffer.adoptBuffer(this.balance, source.length + 1);\n    let tokenCount = 0;\n    let balanceCloseType = 0;\n    let balanceStart = 0;\n    let firstCharOffset = -1;\n\n    // capture buffers\n    this.offsetAndType = null;\n    this.balance = null;\n    tokenize(source, (type, start, end) => {\n      switch (type) {\n        default:\n          balance[tokenCount] = sourceLength;\n          break;\n        case balanceCloseType:\n          {\n            let balancePrev = balanceStart & OFFSET_MASK;\n            balanceStart = balance[balancePrev];\n            balanceCloseType = balanceStart >> TYPE_SHIFT;\n            balance[tokenCount] = balancePrev;\n            balance[balancePrev++] = tokenCount;\n            for (; balancePrev < tokenCount; balancePrev++) {\n              if (balance[balancePrev] === sourceLength) {\n                balance[balancePrev] = tokenCount;\n              }\n            }\n            break;\n          }\n        case types.LeftParenthesis:\n        case types.Function:\n        case types.LeftSquareBracket:\n        case types.LeftCurlyBracket:\n          balance[tokenCount] = balanceStart;\n          balanceCloseType = balancePair.get(type);\n          balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;\n          break;\n      }\n      offsetAndType[tokenCount++] = type << TYPE_SHIFT | end;\n      if (firstCharOffset === -1) {\n        firstCharOffset = start;\n      }\n    });\n\n    // finalize buffers\n    offsetAndType[tokenCount] = types.EOF << TYPE_SHIFT | sourceLength; // <EOF-token>\n    balance[tokenCount] = sourceLength;\n    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token\n    while (balanceStart !== 0) {\n      const balancePrev = balanceStart & OFFSET_MASK;\n      balanceStart = balance[balancePrev];\n      balance[balancePrev] = sourceLength;\n    }\n    this.source = source;\n    this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;\n    this.tokenCount = tokenCount;\n    this.offsetAndType = offsetAndType;\n    this.balance = balance;\n    this.reset();\n    this.next();\n  }\n  lookupType(offset) {\n    offset += this.tokenIndex;\n    if (offset < this.tokenCount) {\n      return this.offsetAndType[offset] >> TYPE_SHIFT;\n    }\n    return types.EOF;\n  }\n  lookupOffset(offset) {\n    offset += this.tokenIndex;\n    if (offset < this.tokenCount) {\n      return this.offsetAndType[offset - 1] & OFFSET_MASK;\n    }\n    return this.source.length;\n  }\n  lookupValue(offset, referenceStr) {\n    offset += this.tokenIndex;\n    if (offset < this.tokenCount) {\n      return utils.cmpStr(this.source, this.offsetAndType[offset - 1] & OFFSET_MASK, this.offsetAndType[offset] & OFFSET_MASK, referenceStr);\n    }\n    return false;\n  }\n  getTokenStart(tokenIndex) {\n    if (tokenIndex === this.tokenIndex) {\n      return this.tokenStart;\n    }\n    if (tokenIndex > 0) {\n      return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;\n    }\n    return this.firstCharOffset;\n  }\n  substrToCursor(start) {\n    return this.source.substring(start, this.tokenStart);\n  }\n  isBalanceEdge(pos) {\n    return this.balance[this.tokenIndex] < pos;\n  }\n  isDelim(code, offset) {\n    if (offset) {\n      return this.lookupType(offset) === types.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;\n    }\n    return this.tokenType === types.Delim && this.source.charCodeAt(this.tokenStart) === code;\n  }\n  skip(tokenCount) {\n    let next = this.tokenIndex + tokenCount;\n    if (next < this.tokenCount) {\n      this.tokenIndex = next;\n      this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;\n      next = this.offsetAndType[next];\n      this.tokenType = next >> TYPE_SHIFT;\n      this.tokenEnd = next & OFFSET_MASK;\n    } else {\n      this.tokenIndex = this.tokenCount;\n      this.next();\n    }\n  }\n  next() {\n    let next = this.tokenIndex + 1;\n    if (next < this.tokenCount) {\n      this.tokenIndex = next;\n      this.tokenStart = this.tokenEnd;\n      next = this.offsetAndType[next];\n      this.tokenType = next >> TYPE_SHIFT;\n      this.tokenEnd = next & OFFSET_MASK;\n    } else {\n      this.eof = true;\n      this.tokenIndex = this.tokenCount;\n      this.tokenType = types.EOF;\n      this.tokenStart = this.tokenEnd = this.source.length;\n    }\n  }\n  skipSC() {\n    while (this.tokenType === types.WhiteSpace || this.tokenType === types.Comment) {\n      this.next();\n    }\n  }\n  skipUntilBalanced(startToken, stopConsume) {\n    let cursor = startToken;\n    let balanceEnd;\n    let offset;\n    loop: for (; cursor < this.tokenCount; cursor++) {\n      balanceEnd = this.balance[cursor];\n\n      // stop scanning on balance edge that points to offset before start token\n      if (balanceEnd < startToken) {\n        break loop;\n      }\n      offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;\n\n      // check stop condition\n      switch (stopConsume(this.source.charCodeAt(offset))) {\n        case 1:\n          // just stop\n          break loop;\n        case 2:\n          // stop & included\n          cursor++;\n          break loop;\n        default:\n          // fast forward to the end of balanced block\n          if (this.balance[balanceEnd] === cursor) {\n            cursor = balanceEnd;\n          }\n      }\n    }\n    this.skip(cursor - this.tokenIndex);\n  }\n  forEachToken(fn) {\n    for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {\n      const start = offset;\n      const item = this.offsetAndType[i];\n      const end = item & OFFSET_MASK;\n      const type = item >> TYPE_SHIFT;\n      offset = end;\n      fn(type, start, end, i);\n    }\n  }\n  dump() {\n    const tokens = new Array(this.tokenCount);\n    this.forEachToken((type, start, end, index) => {\n      tokens[index] = {\n        idx: index,\n        type: names[type],\n        chunk: this.source.substring(start, end),\n        balance: this.balance[index]\n      };\n    });\n    return tokens;\n  }\n}\nexports.TokenStream = TokenStream;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}