{"ast":null,"code":"'use strict';\n\nfunction noop(value) {\n  return value;\n}\nfunction generateMultiplier(multiplier) {\n  const {\n    min,\n    max,\n    comma\n  } = multiplier;\n  if (min === 0 && max === 0) {\n    return comma ? '#?' : '*';\n  }\n  if (min === 0 && max === 1) {\n    return '?';\n  }\n  if (min === 1 && max === 0) {\n    return comma ? '#' : '+';\n  }\n  if (min === 1 && max === 1) {\n    return '';\n  }\n  return (comma ? '#' : '') + (min === max ? '{' + min + '}' : '{' + min + ',' + (max !== 0 ? max : '') + '}');\n}\nfunction generateTypeOpts(node) {\n  switch (node.type) {\n    case 'Range':\n      return ' [' + (node.min === null ? '-∞' : node.min) + ',' + (node.max === null ? '∞' : node.max) + ']';\n    default:\n      throw new Error('Unknown node type `' + node.type + '`');\n  }\n}\nfunction generateSequence(node, decorate, forceBraces, compact) {\n  const combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';\n  const result = node.terms.map(term => internalGenerate(term, decorate, forceBraces, compact)).join(combinator);\n  if (node.explicit || forceBraces) {\n    return (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');\n  }\n  return result;\n}\nfunction internalGenerate(node, decorate, forceBraces, compact) {\n  let result;\n  switch (node.type) {\n    case 'Group':\n      result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? '!' : '');\n      break;\n    case 'Multiplier':\n      // return since node is a composition\n      return internalGenerate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);\n    case 'Type':\n      result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';\n      break;\n    case 'Property':\n      result = '<\\'' + node.name + '\\'>';\n      break;\n    case 'Keyword':\n      result = node.name;\n      break;\n    case 'AtKeyword':\n      result = '@' + node.name;\n      break;\n    case 'Function':\n      result = node.name + '(';\n      break;\n    case 'String':\n    case 'Token':\n      result = node.value;\n      break;\n    case 'Comma':\n      result = ',';\n      break;\n    default:\n      throw new Error('Unknown node type `' + node.type + '`');\n  }\n  return decorate(result, node);\n}\nfunction generate(node, options) {\n  let decorate = noop;\n  let forceBraces = false;\n  let compact = false;\n  if (typeof options === 'function') {\n    decorate = options;\n  } else if (options) {\n    forceBraces = Boolean(options.forceBraces);\n    compact = Boolean(options.compact);\n    if (typeof options.decorate === 'function') {\n      decorate = options.decorate;\n    }\n  }\n  return internalGenerate(node, decorate, forceBraces, compact);\n}\nexports.generate = generate;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}