{"ast":null,"code":"'use strict';\n\nconst cssTree = require('css-tree');\nconst utils = require('./utils.cjs');\nfunction calcSelectorLength(list) {\n  return list.reduce((res, data) => res + data.id.length + 1, 0) - 1;\n}\nfunction calcDeclarationsLength(tokens) {\n  let length = 0;\n  for (const token of tokens) {\n    length += token.length;\n  }\n  return length +\n  // declarations\n  tokens.length - 1 // delimeters\n  ;\n}\nfunction processRule(node, item, list) {\n  const avoidRulesMerge = this.block !== null ? this.block.avoidRulesMerge : false;\n  const selectors = node.prelude.children;\n  const block = node.block;\n  const disallowDownMarkers = Object.create(null);\n  let allowMergeUp = true;\n  let allowMergeDown = true;\n  list.prevUntil(item.prev, function (prev, prevItem) {\n    const prevBlock = prev.block;\n    const prevType = prev.type;\n    if (prevType !== 'Rule') {\n      const unsafe = utils.unsafeToSkipNode.call(selectors, prev);\n      if (!unsafe && prevType === 'Atrule' && prevBlock) {\n        cssTree.walk(prevBlock, {\n          visit: 'Rule',\n          enter(node) {\n            node.prelude.children.forEach(data => {\n              disallowDownMarkers[data.compareMarker] = true;\n            });\n          }\n        });\n      }\n      return unsafe;\n    }\n    if (node.pseudoSignature !== prev.pseudoSignature) {\n      return true;\n    }\n    const prevSelectors = prev.prelude.children;\n    allowMergeDown = !prevSelectors.some(selector => selector.compareMarker in disallowDownMarkers);\n\n    // try prev ruleset if simpleselectors has no equal specifity and element selector\n    if (!allowMergeDown && !allowMergeUp) {\n      return true;\n    }\n\n    // try to join by selectors\n    if (allowMergeUp && utils.isEqualSelectors(prevSelectors, selectors)) {\n      prevBlock.children.appendList(block.children);\n      list.remove(item);\n      return true;\n    }\n\n    // try to join by properties\n    const diff = utils.compareDeclarations(block.children, prevBlock.children);\n\n    // console.log(diff.eq, diff.ne1, diff.ne2);\n\n    if (diff.eq.length) {\n      if (!diff.ne1.length && !diff.ne2.length) {\n        // equal blocks\n        if (allowMergeDown) {\n          utils.addSelectors(selectors, prevSelectors);\n          list.remove(prevItem);\n        }\n        return true;\n      } else if (!avoidRulesMerge) {\n        /* probably we don't need to prevent those merges for @keyframes\n           TODO: need to be checked */\n\n        if (diff.ne1.length && !diff.ne2.length) {\n          // prevBlock is subset block\n          const selectorLength = calcSelectorLength(selectors);\n          const blockLength = calcDeclarationsLength(diff.eq); // declarations length\n\n          if (allowMergeUp && selectorLength < blockLength) {\n            utils.addSelectors(prevSelectors, selectors);\n            block.children.fromArray(diff.ne1);\n          }\n        } else if (!diff.ne1.length && diff.ne2.length) {\n          // node is subset of prevBlock\n          const selectorLength = calcSelectorLength(prevSelectors);\n          const blockLength = calcDeclarationsLength(diff.eq); // declarations length\n\n          if (allowMergeDown && selectorLength < blockLength) {\n            utils.addSelectors(selectors, prevSelectors);\n            prevBlock.children.fromArray(diff.ne2);\n          }\n        } else {\n          // diff.ne1.length && diff.ne2.length\n          // extract equal block\n          const newSelector = {\n            type: 'SelectorList',\n            loc: null,\n            children: utils.addSelectors(prevSelectors.copy(), selectors)\n          };\n          const newBlockLength = calcSelectorLength(newSelector.children) + 2; // selectors length + curly braces length\n          const blockLength = calcDeclarationsLength(diff.eq); // declarations length\n\n          // create new ruleset if declarations length greater than\n          // ruleset description overhead\n          if (blockLength >= newBlockLength) {\n            const newItem = list.createItem({\n              type: 'Rule',\n              loc: null,\n              prelude: newSelector,\n              block: {\n                type: 'Block',\n                loc: null,\n                children: new cssTree.List().fromArray(diff.eq)\n              },\n              pseudoSignature: node.pseudoSignature\n            });\n            block.children.fromArray(diff.ne1);\n            prevBlock.children.fromArray(diff.ne2overrided);\n            if (allowMergeUp) {\n              list.insert(newItem, prevItem);\n            } else {\n              list.insert(newItem, item);\n            }\n            return true;\n          }\n        }\n      }\n    }\n    if (allowMergeUp) {\n      // TODO: disallow up merge only if any property interception only (i.e. diff.ne2overrided.length > 0);\n      // await property families to find property interception correctly\n      allowMergeUp = !prevSelectors.some(prevSelector => selectors.some(selector => selector.compareMarker === prevSelector.compareMarker));\n    }\n    prevSelectors.forEach(data => {\n      disallowDownMarkers[data.compareMarker] = true;\n    });\n  });\n}\nfunction restructRule(ast) {\n  cssTree.walk(ast, {\n    visit: 'Rule',\n    reverse: true,\n    enter: processRule\n  });\n}\nmodule.exports = restructRule;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}