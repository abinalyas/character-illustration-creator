{"ast":null,"code":"'use strict';\n\nconst cssTree = require('css-tree');\nfunction ensureSelectorList(node) {\n  if (node.type === 'Raw') {\n    return cssTree.parse(node.value, {\n      context: 'selectorList'\n    });\n  }\n  return node;\n}\nfunction maxSpecificity(a, b) {\n  for (let i = 0; i < 3; i++) {\n    if (a[i] !== b[i]) {\n      return a[i] > b[i] ? a : b;\n    }\n  }\n  return a;\n}\nfunction maxSelectorListSpecificity(selectorList) {\n  return ensureSelectorList(selectorList).children.reduce((result, node) => maxSpecificity(specificity(node), result), [0, 0, 0]);\n}\n\n// §16. Calculating a selector’s specificity\n// https://www.w3.org/TR/selectors-4/#specificity-rules\nfunction specificity(simpleSelector) {\n  let A = 0;\n  let B = 0;\n  let C = 0;\n\n  // A selector’s specificity is calculated for a given element as follows:\n  simpleSelector.children.forEach(node => {\n    switch (node.type) {\n      // count the number of ID selectors in the selector (= A)\n      case 'IdSelector':\n        A++;\n        break;\n\n      // count the number of class selectors, attributes selectors, ...\n      case 'ClassSelector':\n      case 'AttributeSelector':\n        B++;\n        break;\n\n      // ... and pseudo-classes in the selector (= B)\n      case 'PseudoClassSelector':\n        switch (node.name.toLowerCase()) {\n          // The specificity of an :is(), :not(), or :has() pseudo-class is replaced\n          // by the specificity of the most specific complex selector in its selector list argument.\n          case 'not':\n          case 'has':\n          case 'is':\n          // :matches() is used before it was renamed to :is()\n          // https://github.com/w3c/csswg-drafts/issues/3258\n          case 'matches':\n          // Older browsers support :is() functionality as prefixed pseudo-class :any()\n          // https://developer.mozilla.org/en-US/docs/Web/CSS/:is\n          case '-webkit-any':\n          case '-moz-any':\n            {\n              const [a, b, c] = maxSelectorListSpecificity(node.children.first);\n              A += a;\n              B += b;\n              C += c;\n              break;\n            }\n\n          // Analogously, the specificity of an :nth-child() or :nth-last-child() selector\n          // is the specificity of the pseudo class itself (counting as one pseudo-class selector)\n          // plus the specificity of the most specific complex selector in its selector list argument (if any).\n          case 'nth-child':\n          case 'nth-last-child':\n            {\n              const arg = node.children.first;\n              if (arg.type === 'Nth' && arg.selector) {\n                const [a, b, c] = maxSelectorListSpecificity(arg.selector);\n                A += a;\n                B += b + 1;\n                C += c;\n              } else {\n                B++;\n              }\n              break;\n            }\n\n          // The specificity of a :where() pseudo-class is replaced by zero.\n          case 'where':\n            break;\n\n          // The four Level 2 pseudo-elements (::before, ::after, ::first-line, and ::first-letter) may,\n          // for legacy reasons, be represented using the <pseudo-class-selector> grammar,\n          // with only a single \":\" character at their start.\n          // https://www.w3.org/TR/selectors-4/#single-colon-pseudos\n          case 'before':\n          case 'after':\n          case 'first-line':\n          case 'first-letter':\n            C++;\n            break;\n          default:\n            B++;\n        }\n        break;\n\n      // count the number of type selectors ...\n      case 'TypeSelector':\n        // ignore the universal selector\n        if (!node.name.endsWith('*')) {\n          C++;\n        }\n        break;\n\n      // ... and pseudo-elements in the selector (= C)\n      case 'PseudoElementSelector':\n        C++;\n        break;\n    }\n  });\n  return [A, B, C];\n}\nmodule.exports = specificity;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}