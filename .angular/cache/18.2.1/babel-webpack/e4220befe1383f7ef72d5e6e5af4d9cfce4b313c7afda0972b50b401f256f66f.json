{"ast":null,"code":"'use strict';\n\nconst {\n  elems\n} = require('./_collections');\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n */\n\nexports.name = 'removeXlink';\nexports.description = 'remove xlink namespace and replaces attributes with the SVG 2 equivalent where applicable';\n\n/** URI indicating the Xlink namespace. */\nconst XLINK_NAMESPACE = 'http://www.w3.org/1999/xlink';\n\n/**\n * Map of `xlink:show` values to the SVG 2 `target` attribute values.\n *\n * @type {Record<string, string>}\n * @see https://developer.mozilla.org/docs/Web/SVG/Attribute/xlink:show#usage_notes\n */\nconst SHOW_TO_TARGET = {\n  new: '_blank',\n  replace: '_self'\n};\n\n/**\n * Elements that use xlink:href, but were deprecated in SVG 2 and therefore\n * don't support the SVG 2 href attribute.\n *\n * @type {Set<string>}\n * @see https://developer.mozilla.org/docs/Web/SVG/Attribute/xlink:href\n * @see https://developer.mozilla.org/docs/Web/SVG/Attribute/href\n */\nconst LEGACY_ELEMENTS = new Set(['cursor', 'filter', 'font-face-uri', 'glyphRef', 'tref']);\n\n/**\n * @param {XastElement} node\n * @param {string[]} prefixes\n * @param {string} attr\n * @returns {string[]}\n */\nconst findPrefixedAttrs = (node, prefixes, attr) => {\n  return prefixes.map(prefix => `${prefix}:${attr}`).filter(attr => node.attributes[attr] != null);\n};\n\n/**\n * Removes XLink namespace prefixes and converts references to XLink attributes\n * to the native SVG equivalent.\n *\n * The XLink namespace is deprecated in SVG 2.\n *\n * @type {import('./plugins-types').Plugin<'removeXlink'>}\n * @see https://developer.mozilla.org/docs/Web/SVG/Attribute/xlink:href\n */\nexports.fn = (_, params) => {\n  const {\n    includeLegacy\n  } = params;\n\n  /**\n   * XLink namespace prefixes that are currently in the stack.\n   *\n   * @type {string[]}\n   */\n  const xlinkPrefixes = [];\n\n  /**\n   * Namespace prefixes that exist in {@link xlinkPrefixes} but were overridden\n   * in a child element to point to another namespace, and so is not treated as\n   * an XLink attribute.\n   *\n   * @type {string[]}\n   */\n  const overriddenPrefixes = [];\n\n  /**\n   * Namespace prefixes that were used in one of the {@link LEGACY_ELEMENTS}.\n   *\n   * @type {string[]}\n   */\n  const usedInLegacyElement = [];\n  return {\n    element: {\n      enter: node => {\n        for (const [key, value] of Object.entries(node.attributes)) {\n          if (key.startsWith('xmlns:')) {\n            const prefix = key.split(':', 2)[1];\n            if (value === XLINK_NAMESPACE) {\n              xlinkPrefixes.push(prefix);\n              continue;\n            }\n            if (xlinkPrefixes.includes(prefix)) {\n              overriddenPrefixes.push(prefix);\n            }\n          }\n        }\n        if (overriddenPrefixes.some(prefix => xlinkPrefixes.includes(prefix))) {\n          return;\n        }\n        const showAttrs = findPrefixedAttrs(node, xlinkPrefixes, 'show');\n        let showHandled = node.attributes.target != null;\n        for (let i = showAttrs.length - 1; i >= 0; i--) {\n          const attr = showAttrs[i];\n          const value = node.attributes[attr];\n          const mapping = SHOW_TO_TARGET[value];\n          if (showHandled || mapping == null) {\n            delete node.attributes[attr];\n            continue;\n          }\n          if (mapping !== elems[node.name]?.defaults?.target) {\n            node.attributes.target = mapping;\n          }\n          delete node.attributes[attr];\n          showHandled = true;\n        }\n        const titleAttrs = findPrefixedAttrs(node, xlinkPrefixes, 'title');\n        for (let i = titleAttrs.length - 1; i >= 0; i--) {\n          const attr = titleAttrs[i];\n          const value = node.attributes[attr];\n          const hasTitle = node.children.filter(child => child.type === 'element' && child.name === 'title');\n          if (hasTitle.length > 0) {\n            delete node.attributes[attr];\n            continue;\n          }\n\n          /** @type {XastElement} */\n          const titleTag = {\n            type: 'element',\n            name: 'title',\n            attributes: {},\n            children: [{\n              type: 'text',\n              value\n            }]\n          };\n          Object.defineProperty(titleTag, 'parentNode', {\n            writable: true,\n            value: node\n          });\n          node.children.unshift(titleTag);\n          delete node.attributes[attr];\n        }\n        const hrefAttrs = findPrefixedAttrs(node, xlinkPrefixes, 'href');\n        if (hrefAttrs.length > 0 && LEGACY_ELEMENTS.has(node.name) && !includeLegacy) {\n          hrefAttrs.map(attr => attr.split(':', 1)[0]).forEach(prefix => usedInLegacyElement.push(prefix));\n          return;\n        }\n        for (let i = hrefAttrs.length - 1; i >= 0; i--) {\n          const attr = hrefAttrs[i];\n          const value = node.attributes[attr];\n          if (node.attributes.href != null) {\n            delete node.attributes[attr];\n            continue;\n          }\n          node.attributes.href = value;\n          delete node.attributes[attr];\n        }\n      },\n      exit: node => {\n        for (const [key, value] of Object.entries(node.attributes)) {\n          const [prefix, attr] = key.split(':', 2);\n          if (xlinkPrefixes.includes(prefix) && !overriddenPrefixes.includes(prefix) && !usedInLegacyElement.includes(prefix) && !includeLegacy) {\n            delete node.attributes[key];\n            continue;\n          }\n          if (key.startsWith('xmlns:') && !usedInLegacyElement.includes(attr)) {\n            if (value === XLINK_NAMESPACE) {\n              const index = xlinkPrefixes.indexOf(attr);\n              xlinkPrefixes.splice(index, 1);\n              delete node.attributes[key];\n              continue;\n            }\n            if (overriddenPrefixes.includes(prefix)) {\n              const index = overriddenPrefixes.indexOf(attr);\n              overriddenPrefixes.splice(index, 1);\n            }\n          }\n        }\n      }\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}