{"ast":null,"code":"'use strict';\n\nconst charCodeDefinitions = require('./char-code-definitions.cjs');\nfunction getCharCode(source, offset) {\n  return offset < source.length ? source.charCodeAt(offset) : 0;\n}\nfunction getNewlineLength(source, offset, code) {\n  if (code === 13 /* \\r */ && getCharCode(source, offset + 1) === 10 /* \\n */) {\n    return 2;\n  }\n  return 1;\n}\nfunction cmpChar(testStr, offset, referenceCode) {\n  let code = testStr.charCodeAt(offset);\n\n  // code.toLowerCase() for A..Z\n  if (charCodeDefinitions.isUppercaseLetter(code)) {\n    code = code | 32;\n  }\n  return code === referenceCode;\n}\nfunction cmpStr(testStr, start, end, referenceStr) {\n  if (end - start !== referenceStr.length) {\n    return false;\n  }\n  if (start < 0 || end > testStr.length) {\n    return false;\n  }\n  for (let i = start; i < end; i++) {\n    const referenceCode = referenceStr.charCodeAt(i - start);\n    let testCode = testStr.charCodeAt(i);\n\n    // testCode.toLowerCase() for A..Z\n    if (charCodeDefinitions.isUppercaseLetter(testCode)) {\n      testCode = testCode | 32;\n    }\n    if (testCode !== referenceCode) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction findWhiteSpaceStart(source, offset) {\n  for (; offset >= 0; offset--) {\n    if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {\n      break;\n    }\n  }\n  return offset + 1;\n}\nfunction findWhiteSpaceEnd(source, offset) {\n  for (; offset < source.length; offset++) {\n    if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {\n      break;\n    }\n  }\n  return offset;\n}\nfunction findDecimalNumberEnd(source, offset) {\n  for (; offset < source.length; offset++) {\n    if (!charCodeDefinitions.isDigit(source.charCodeAt(offset))) {\n      break;\n    }\n  }\n  return offset;\n}\n\n// § 4.3.7. Consume an escaped code point\nfunction consumeEscaped(source, offset) {\n  // It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and\n  // that the next input code point has already been verified to be part of a valid escape.\n  offset += 2;\n\n  // hex digit\n  if (charCodeDefinitions.isHexDigit(getCharCode(source, offset - 1))) {\n    // Consume as many hex digits as possible, but no more than 5.\n    // Note that this means 1-6 hex digits have been consumed in total.\n    for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {\n      if (!charCodeDefinitions.isHexDigit(getCharCode(source, offset))) {\n        break;\n      }\n    }\n\n    // If the next input code point is whitespace, consume it as well.\n    const code = getCharCode(source, offset);\n    if (charCodeDefinitions.isWhiteSpace(code)) {\n      offset += getNewlineLength(source, offset, code);\n    }\n  }\n  return offset;\n}\n\n// §4.3.11. Consume a name\n// Note: This algorithm does not do the verification of the first few code points that are necessary\n// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,\n// ensure that the stream starts with an identifier before calling this algorithm.\nfunction consumeName(source, offset) {\n  // Let result initially be an empty string.\n  // Repeatedly consume the next input code point from the stream:\n  for (; offset < source.length; offset++) {\n    const code = source.charCodeAt(offset);\n\n    // name code point\n    if (charCodeDefinitions.isName(code)) {\n      // Append the code point to result.\n      continue;\n    }\n\n    // the stream starts with a valid escape\n    if (charCodeDefinitions.isValidEscape(code, getCharCode(source, offset + 1))) {\n      // Consume an escaped code point. Append the returned code point to result.\n      offset = consumeEscaped(source, offset) - 1;\n      continue;\n    }\n\n    // anything else\n    // Reconsume the current input code point. Return result.\n    break;\n  }\n  return offset;\n}\n\n// §4.3.12. Consume a number\nfunction consumeNumber(source, offset) {\n  let code = source.charCodeAt(offset);\n\n  // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n  // consume it and append it to repr.\n  if (code === 0x002B || code === 0x002D) {\n    code = source.charCodeAt(offset += 1);\n  }\n\n  // 3. While the next input code point is a digit, consume it and append it to repr.\n  if (charCodeDefinitions.isDigit(code)) {\n    offset = findDecimalNumberEnd(source, offset + 1);\n    code = source.charCodeAt(offset);\n  }\n\n  // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n  if (code === 0x002E && charCodeDefinitions.isDigit(source.charCodeAt(offset + 1))) {\n    // 4.1 Consume them.\n    // 4.2 Append them to repr.\n    offset += 2;\n\n    // 4.3 Set type to \"number\".\n    // TODO\n\n    // 4.4 While the next input code point is a digit, consume it and append it to repr.\n\n    offset = findDecimalNumberEnd(source, offset);\n  }\n\n  // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n  // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n  if (cmpChar(source, offset, 101 /* e */)) {\n    let sign = 0;\n    code = source.charCodeAt(offset + 1);\n\n    // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n    if (code === 0x002D || code === 0x002B) {\n      sign = 1;\n      code = source.charCodeAt(offset + 2);\n    }\n\n    // ... followed by a digit\n    if (charCodeDefinitions.isDigit(code)) {\n      // 5.1 Consume them.\n      // 5.2 Append them to repr.\n\n      // 5.3 Set type to \"number\".\n      // TODO\n\n      // 5.4 While the next input code point is a digit, consume it and append it to repr.\n      offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);\n    }\n  }\n  return offset;\n}\n\n// § 4.3.14. Consume the remnants of a bad url\n// ... its sole use is to consume enough of the input stream to reach a recovery point\n// where normal tokenizing can resume.\nfunction consumeBadUrlRemnants(source, offset) {\n  // Repeatedly consume the next input code point from the stream:\n  for (; offset < source.length; offset++) {\n    const code = source.charCodeAt(offset);\n\n    // U+0029 RIGHT PARENTHESIS ())\n    // EOF\n    if (code === 0x0029) {\n      // Return.\n      offset++;\n      break;\n    }\n    if (charCodeDefinitions.isValidEscape(code, getCharCode(source, offset + 1))) {\n      // Consume an escaped code point.\n      // Note: This allows an escaped right parenthesis (\"\\)\") to be encountered\n      // without ending the <bad-url-token>. This is otherwise identical to\n      // the \"anything else\" clause.\n      offset = consumeEscaped(source, offset);\n    }\n  }\n  return offset;\n}\n\n// § 4.3.7. Consume an escaped code point\n// Note: This algorithm assumes that escaped is valid without leading U+005C REVERSE SOLIDUS (\\)\nfunction decodeEscaped(escaped) {\n  // Single char escaped that's not a hex digit\n  if (escaped.length === 1 && !charCodeDefinitions.isHexDigit(escaped.charCodeAt(0))) {\n    return escaped[0];\n  }\n\n  // Interpret the hex digits as a hexadecimal number.\n  let code = parseInt(escaped, 16);\n  if (code === 0 ||\n  // If this number is zero,\n  code >= 0xD800 && code <= 0xDFFF ||\n  // or is for a surrogate,\n  code > 0x10FFFF // or is greater than the maximum allowed code point\n  ) {\n    // ... return U+FFFD REPLACEMENT CHARACTER\n    code = 0xFFFD;\n  }\n\n  // Otherwise, return the code point with that value.\n  return String.fromCodePoint(code);\n}\nexports.cmpChar = cmpChar;\nexports.cmpStr = cmpStr;\nexports.consumeBadUrlRemnants = consumeBadUrlRemnants;\nexports.consumeEscaped = consumeEscaped;\nexports.consumeName = consumeName;\nexports.consumeNumber = consumeNumber;\nexports.decodeEscaped = decodeEscaped;\nexports.findDecimalNumberEnd = findDecimalNumberEnd;\nexports.findWhiteSpaceEnd = findWhiteSpaceEnd;\nexports.findWhiteSpaceStart = findWhiteSpaceStart;\nexports.getNewlineLength = getNewlineLength;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}