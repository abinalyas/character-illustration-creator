{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {import('../lib/types').XastElement} XastElement\n */\nconst {\n  visitSkip\n} = require('../lib/xast.js');\nconst {\n  hasScripts,\n  findReferences\n} = require('../lib/svgo/tools');\nexports.name = 'cleanupIds';\nexports.description = 'removes unused IDs and minifies used';\nconst generateIdChars = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\nconst maxIdIndex = generateIdChars.length - 1;\n\n/**\n * Check if an ID starts with any one of a list of strings.\n *\n * @type {(string: string, prefixes: string[]) => boolean}\n */\nconst hasStringPrefix = (string, prefixes) => {\n  for (const prefix of prefixes) {\n    if (string.startsWith(prefix)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Generate unique minimal ID.\n *\n * @param {?number[]} currentId\n * @returns {number[]}\n */\nconst generateId = currentId => {\n  if (currentId == null) {\n    return [0];\n  }\n  currentId[currentId.length - 1] += 1;\n  for (let i = currentId.length - 1; i > 0; i--) {\n    if (currentId[i] > maxIdIndex) {\n      currentId[i] = 0;\n      if (currentId[i - 1] !== undefined) {\n        currentId[i - 1]++;\n      }\n    }\n  }\n  if (currentId[0] > maxIdIndex) {\n    currentId[0] = 0;\n    currentId.unshift(0);\n  }\n  return currentId;\n};\n\n/**\n * Get string from generated ID array.\n *\n * @type {(arr: number[]) => string}\n */\nconst getIdString = arr => {\n  return arr.map(i => generateIdChars[i]).join('');\n};\n\n/**\n * Remove unused and minify used IDs\n * (only if there are no any <style> or <script>).\n *\n * @author Kir Belevich\n *\n * @type {import('./plugins-types').Plugin<'cleanupIds'>}\n */\nexports.fn = (_root, params) => {\n  const {\n    remove = true,\n    minify = true,\n    preserve = [],\n    preservePrefixes = [],\n    force = false\n  } = params;\n  const preserveIds = new Set(Array.isArray(preserve) ? preserve : preserve ? [preserve] : []);\n  const preserveIdPrefixes = Array.isArray(preservePrefixes) ? preservePrefixes : preservePrefixes ? [preservePrefixes] : [];\n  /**\n   * @type {Map<string, XastElement>}\n   */\n  const nodeById = new Map();\n  /**\n   * @type {Map<string, {element: XastElement, name: string }[]>}\n   */\n  const referencesById = new Map();\n  let deoptimized = false;\n  return {\n    element: {\n      enter: node => {\n        if (!force) {\n          // deoptimize if style or scripts are present\n          if (node.name === 'style' && node.children.length !== 0 || hasScripts(node)) {\n            deoptimized = true;\n            return;\n          }\n\n          // avoid removing IDs if the whole SVG consists only of defs\n          if (node.name === 'svg') {\n            let hasDefsOnly = true;\n            for (const child of node.children) {\n              if (child.type !== 'element' || child.name !== 'defs') {\n                hasDefsOnly = false;\n                break;\n              }\n            }\n            if (hasDefsOnly) {\n              return visitSkip;\n            }\n          }\n        }\n        for (const [name, value] of Object.entries(node.attributes)) {\n          if (name === 'id') {\n            // collect all ids\n            const id = value;\n            if (nodeById.has(id)) {\n              delete node.attributes.id; // remove repeated id\n            } else {\n              nodeById.set(id, node);\n            }\n          } else {\n            const ids = findReferences(name, value);\n            for (const id of ids) {\n              let refs = referencesById.get(id);\n              if (refs == null) {\n                refs = [];\n                referencesById.set(id, refs);\n              }\n              refs.push({\n                element: node,\n                name\n              });\n            }\n          }\n        }\n      }\n    },\n    root: {\n      exit: () => {\n        if (deoptimized) {\n          return;\n        }\n        /**\n         * @param {string} id\n         * @returns {boolean}\n         */\n        const isIdPreserved = id => preserveIds.has(id) || hasStringPrefix(id, preserveIdPrefixes);\n        /** @type {?number[]} */\n        let currentId = null;\n        for (const [id, refs] of referencesById) {\n          const node = nodeById.get(id);\n          if (node != null) {\n            // replace referenced IDs with the minified ones\n            if (minify && isIdPreserved(id) === false) {\n              /** @type {?string} */\n              let currentIdString = null;\n              do {\n                currentId = generateId(currentId);\n                currentIdString = getIdString(currentId);\n              } while (isIdPreserved(currentIdString) || referencesById.has(currentIdString) && nodeById.get(currentIdString) == null);\n              node.attributes.id = currentIdString;\n              for (const {\n                element,\n                name\n              } of refs) {\n                const value = element.attributes[name];\n                if (value.includes('#')) {\n                  // replace id in href and url()\n                  element.attributes[name] = value.replace(`#${encodeURI(id)}`, `#${currentIdString}`);\n                } else {\n                  // replace id in begin attribute\n                  element.attributes[name] = value.replace(`${id}.`, `${currentIdString}.`);\n                }\n              }\n            }\n            // keep referenced node\n            nodeById.delete(id);\n          }\n        }\n        // remove non-referenced IDs attributes from elements\n        if (remove) {\n          for (const [id, node] of nodeById) {\n            if (isIdPreserved(id) === false) {\n              delete node.attributes.id;\n            }\n          }\n        }\n      }\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}